#!/usr/bin/perl -w
###!@PERL@ -w

##############################################################################
# File   : backup
# Authors: Sebastien VARRETTE     <Sebastien.Varrette@uni.lu>
#          Guillaume-Jean HERBIET <Guillaume.Herbiet@uni.lu>
# $Id$
#
# Description : @PACKAGE_SUMMARY@
#               For more information: see backup(3) or
#               @PACKAGE_WEBSITE@
#
# Copyright (c) 2009 Sebastien Varrette     (http://varrette.gforge.uni.lu/)
#                    Guillaume-Jean Herbiet (http://herbiet.gforge.uni.lu/)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.
#
# Sebastien Varrette     <Sebastien.Varrette@uni.lu>\n
# Guillaume-Jean Herbiet <Guillaume.Herbiet@uni.lu> \n
# University of Luxembourg                          \n
# 6, rue Richard Coudenhove-Kalergi                 \n
# L-1359 Luxembourg                                 \n
##############################################################################

### Function prototype declaration ###
sub print::alert(@);
sub print::critical(@);
sub print::debug(@);
sub print::error_nolog_and_exit($@);
sub print::error_and_exit($@);
sub print::error_nolog(@);
sub print::error(@);
sub print::info(@);
sub print::notification($$@);
sub print::really_continue();
sub print::warning(@);
sub print::warn(@);

sub format::color_msg($$);

sub log::initialize(@);

sub system::check_binary(@);
sub system::check_subnet($@);
sub system::execute(@);
sub system::getIPs();
sub system::getIPFromInterface(@);
sub system::remote_execute_by_ssh($$@);


##############################################################################
# PACKAGE PRINT
# Handle all printing features
##############################################################################
package print;

use strict;
use warnings;
use List::Util qw[min max];   # To find min/max values

#our $print_level = 2;

#######
# Print information in the following form: prefix msg
# usage: print::with_prefix(prefix, msg)
###
sub with_prefix($@) {
    my $prefix = shift;
    print "$prefix @_" unless $::QUIET;
}

#######
# print an error information without passing through the log manager
###
sub error_nolog(@) {
    print::with_prefix('[' . format::color_msg('red', 'ERROR') . ']', @_);
}
#####
# the following functions are called to display an information depending on the
# considered level
##
sub error(@)    { $log::handler->error(@_); }
sub debug(@)    { $log::handler->debug(@_) if $main::DEBUG;   }
sub info(@)     { $log::handler->info(@_);  }
sub verbose(@)  { info(@_) if $main::VERBOSE; }
sub warning(@)  { $log::handler->warn(@_);  }
sub warn(@)     { warning(@_); }
sub critical(@) { $log::handler->crit(@_); }
sub alert(@)    { $log::handler->alert(@_); }

####
# Print error message then exit with exit status $_[0]
##
sub error_nolog_and_exit($@) {
    my $exit_code = shift;
    print::error_nolog(@_);
    exit($exit_code);
}
sub error_and_exit($@) {
    my $exit_code = shift;
    print::error(@_);
    exit($exit_code);
}

######
# Send a graphical notification to the user (using growl under Mac or
# notify-send under Linux)
# usage: notification(title, text [, priority])
##
sub notification($$@) {
    my $title    = shift;
    my $text     = shift;
    my $priority = shift;
    $priority    = defined($priority) ? $priority : 0;
    my $notify_cmd="";

    # Select notification system based on system
    if ($main::OS[0] =~ "Darwin") {           # Mac OS X: use growlnotify
        $priority = max(min($priority, 2), -2);
        $notify_cmd =
            'growlnotify -p ' . $priority .
            ' -n '.$main::command.' -a \'iSync\' \'' . $title . '\' '.
            '-m \''. $text .'\' > /dev/null 2>&1';
    } elsif ($main::OS[0] =~ "Linux") {
        $priority = max(min($priority, 1), -1) +1;
        my @levels = ("low", "normal", "critical");
        $notify_cmd =
            'notify-send -u ' . $levels[$priority] .
            ' -i gtk-dialog-info \'' . $title . '\' \'' . $text . '\'';
    } else {
        print::warning('ibackup do not support graphical notification for the ',
                       $main::OS[0], " OS\n");
    }
    system::execute($notify_cmd);
}

######
# Ask the user is he wishes to continue.
##
sub really_continue() {
    print "Are you sure you want to continue? [yN] ";
    chomp(my $ans = <STDIN>);
    unless ($ans && ($ans =~ /y|yes|1/i)) {
        #sync::clean_after_sync();
        exit(0);
    }
}


##############################################################################
# PACKAGE FORMAT
# Handle all reformatting features
##############################################################################
package format;

use strict;
use warnings;
use Term::ANSIColor; # To send the ANSI color-change sequences to the user's terminal

#####
# return a colored message (coloration only appens in the terminal typically)
###
sub color_msg($$) {
    my $color = shift;
    my $msg = shift;
    return  Term::ANSIColor::color("$color") . "$msg" . Term::ANSIColor::color("reset");
}

##############################################################################
# PACKAGE LOG
# Handle all logging features
##############################################################################
package log;
use strict;
use warnings;

use Log::Handler;  # Log manager
#
# The following log levels are defined:
#     7   debug
#     6   info
#     5   notice
#     4   warning, warn
#     3   error, err
#     2   critical, crit
#     1   alert
#     0   emergency, emerg
#
# The message layout in the printf style with the following options:
#
#     %L   Log level
#     %T   Time or full timestamp (option timeformat)
#     %D   Date (option dateformat)
#     %P   PID
#     %H   Hostname
#     %U   User name
#     %G   Group name
#     %N   Newline
#     %S   Program name
#     %C   Caller - filename and line number
#     %p   Caller - package name
#     %f   Caller - file name
#     %l   Caller - line number
#     %s   Caller - subroutine name
#     %r   Runtime in seconds since program start
#     %t   Time measurement - replaced with the time since the last call of $log->$level
#     %m   Message
#     %%   Procent

our $handler    = Log::Handler->new();
our $timeformat = '%Y/%m/%d %H:%M:%S';
our $msg_layout = '%T [%L] %m';

########
# Initialize the log handler
# Usage: initialize([logdir],[email])
#        initialize([logdir])
#        initialize([email])
##
sub initialize(@) {
    my ($logdir, $email) = @_;

    # Recognize a mail address instead of a directory as
    if ((scalar(@_) == 1) &&
        ($logdir =~ /\b[\w0-9._%+-]+@(?:[\w0-9-]+\.)+[\w]{2,4}\b/))
    {
        print "First argument is an email: $logdir\n";
        $email  = $logdir;
        $logdir = undef;
    }
    my $yellow_level  = format::color_msg('yellow',  '%L');
    my $magenta_level = format::color_msg('magenta', '%L');
    my $red_level     = format::color_msg('red',     '%L');

    my $debug_msg_layout = my $error_msg_layout = my $warning_msg_layout = $msg_layout;

    # ===  Initialize screen log (in the terminal) ===
    # Redirect debug logs to STDOUT (in yellow)
    $debug_msg_layout =~ s/%L/$yellow_level/g;
    $handler->add(
        screen => {
            log_to   => "STDOUT",
            maxlevel => 7,
            minlevel => 7,
            timeformat      => "$timeformat",
            message_layout  => "$debug_msg_layout",
        }
        );

    # Redirect common logs to STDOUT
    $handler->add(
        screen => {
            log_to   => "STDOUT",
            maxlevel => 6,
            minlevel => 5,
            timeformat      => "$timeformat",
            message_layout  => "$msg_layout",
        }
        );

    # redirect warnings to STDERR
    $warning_msg_layout =~ s/%L/$magenta_level/g;
    $handler->add(
        screen => {
            log_to   => "STDERR",
            maxlevel => 4,
            minlevel => 4,
            timeformat      => "$timeformat",
            message_layout  => "$warning_msg_layout",
        }
        );

    # Redirect errors to STDERR
    $error_msg_layout =~ s/%L/$red_level/g;
    $handler->add(
        screen => {
            log_to   => "STDERR",
            maxlevel => 3,  # error
            minlevel => 0,  # emerg
            timeformat      => "$timeformat",
            message_layout  => "$error_msg_layout",
        }
        );

    # ===  Initialize file log (in $logdir) ===
    if (defined($logdir)) {
        # ensure the directory exists
        print::error_and_exit(1,
                              "The directory $logdir do not exist: ",
                              "impossible to create log files into ",
                              "this directory\n")
            unless (-d "$logdir");

        # Initialie the log file for common logs
        $handler->add(
            file => {
                filename   => "${logdir}/common.log",
                maxlevel   => 7,  # debug
                minlevel   => 5,  # notice
                timeformat      => "$timeformat",
                message_layout  => "$msg_layout",
            }
            );

        # Initialize the log file for error logs
        $handler->add(
            file => {
                filename => "${logdir}/error.log",
                maxlevel => 4,  # warning
                minlevel => 0,  # emerg
                timeformat      => "$timeformat",
                message_layout  => "$msg_layout",
            }
            );
    }

    # Eventually mail errors/warnings
    if (defined($email)) {
        chomp(my $username = `whoami`);
        chomp(my $hostname = `hostname -f`);
        my $from = $username . '@' . $hostname;
        print::debug("Setup log by mail (from=$from) to $email\n");

        $handler->add(
            sendmail => {
                from     => "${username}\@${hostname}",
                to       => "$email",
                subject  => "(ibackup)",
                maxlevel => 4,
                minlevel => 0,
                message_pattern => '%L',
                timeformat      => "$timeformat",
                message_layout  => "$msg_layout",
            }
            );
    }
}

##############################################################################
# PACKAGE SYSTEM
# Handle all system calls/behaviour/information etc.
##############################################################################
package system;

use strict;
use warnings;
use Data::Dumper;


####
# check the presence of the binaries @_ on the local system using 'which'
# usage:  check_binary(bin1 [, bin2 ...]);
##
sub check_binary(@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    my $which = "$ENV{'PATH'} which";
    foreach my $app (@_) {
        print::verbose("=> check availability of the command '$app' on the local system...");
        verbose("\n") if (($main::DEBUG) || ($main::SIMULATION_MODE));
        execute("which $app 1>/dev/null") ||
            print::error_and_exit(1, "$app: command not found in PATH=$ENV{'PATH'}");
        verbose("\tOK\n");
    }
}

####
# check if the IP associated with an interface match another subnet.
# If no interface argument is provided, then
# usage: check_subnet(subnet [, interface])
##
sub check_subnet($@) {
    my $subnet = shift;
    my $IP = (@_) ? getIPFromInterface($_[0]) : getIPFromInterface();
    print::verbose("=> check subnet $subnet (current IP address found: $IP)");
    my $pattern=$subnet;
    $pattern =~ s/\./\\\./g;   # proceed with the '.' characters
    if ($IP !~ /$pattern/) {
        ibackup::Exception::Network->throw(error => "The IP adress $IP does not belong to the subnet $subnet\n");
    } 
}

#####
# execute a local command
# usage: execute(command)
###
sub execute(@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    print::debug('[' . (caller(0))[3] . "] @_\n");
    ($main::SIMULATION_MODE) ?
        print format::color_msg('bold', "@_\n") : system("@_");
    my $exit_status = $?;
    print::debug('[' . (caller(0))[3] . "] exit status : $exit_status\n");
    return $exit_status;
}

######
# get current IPs adresses using ifconfig.
# return an hash table associating an interface name with an IP and a state (up or down)
##
sub getIPs() {
    my $interface;
    my %IPs;
    foreach ( qx{ (LC_ALL=C /sbin/ifconfig -a 2>&1) } ) {
        $interface = $1 if /^(\S+?):?\s/;
        next unless defined $interface;
        $IPs{$interface}->{STATE}=uc($1) if /\b(up|down)\b/i;
        $IPs{$interface}->{IP}=$1 if /inet\D+(\d+\.\d+\.\d+\.\d+)/i;
    }
    return %IPs;
}

######
# get current IP adresses associated with an interface.
# If the interface parameter is not procided, the checked interfaces ar e (eth0,
# eth1) on Linux system and (en0, en1) on BSD-like.
# usage: getIPFromInterface(interface)
###
sub getIPFromInterface(@) {
    my %IPs = getIPs();
    print::debug("Analysing IPs on the local system. Found:\n");
    print::debug(Dumper \%IPs);
    my @interfaces;
    if (@_) {
        @interfaces = @_;
    } else {
        @interfaces = ('eth0', 'eth1') if ($main::OS[0] eq "Linux");
        @interfaces = ('en0',  'en1')  if ($main::OS[0] =~ "FreeBSD|OpenBSD|Darwin");
    }
    foreach my $i (@interfaces) {
        return $IPs{$i}->{IP} if ($IPs{$i} && $IPs{$i}->{IP});
    }
    # TODO: throw an exception here instead!
    print::error_and_exit(1,"IP not found for interface(s) @interfaces");
    return;
}

#####
# execute a command on a remote server by ssh
# usage: ssh_remote_execute("user@host", port, "command")
###
sub remote_execute_by_ssh($$@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    my ($host, $port, @command) = @_;
    my $cmd = "ssh -p $port $host @command 1>/dev/null";
    return system::execute($cmd);
}

##############################################################################
# PACKAGE sync
# Handle all synchronization aspects etc.
##############################################################################
package sync;

use Hash::Util qw{lock_hash}; # To be able to lock keys/values in hash tables

# Store information on the synchronization command to be issued
our %BACKUP_CMD_INFO = (
    'basecmd'     => 'rsync',
    'opt'         => '',
    'src'         => undef,
    'dst'         => undef,
    'dirs'        => undef,
    'proto'       => undef,
    'port'        => undef,
    'target'      => undef,
    );
our %DEFAULT_BACKUP_CMD_INFO = %BACKUP_CMD_INFO;
lock_hash(%DEFAULT_BACKUP_CMD_INFO); # for extra safety


##############################################################################
# PACKAGE config
# Handle all configuration aspects etc.
##############################################################################
package config;

use strict;
use warnings;

use Hash::Util qw{lock_hash}; # To be able to lock keys/values in hash tables

# Configuration settings as extracted/expanded from the configuration file
our %SETTINGS = (
    'use_duplicity'         => 'no',
    'log_file'              => undef,  # TODO: NOW log dir
    'pass_file'             => undef,
    'patternfile_exclude'   => undef,
    'restrict_on_subnet'    => undef,
    'src_rootdir'           => '/',
    'dst_rootdir'           => '/',
    'include_dir'           => undef,
    'exclude_dir'           => undef,
    'exclude_dir_exception' => undef,
    'Directory'             => undef,
    'target_url'            => undef,
    'logdir'                => undef,
    'email'                 => undef,
    );
our %DEFAULT_SETTINGS = %SETTINGS;
lock_hash(%DEFAULT_SETTINGS);        # for extra safety

##############################################################################
# PACKAGE EXCEPTION
# Handle exceptions etc.
##############################################################################
#package exception;
package ibackup::Exception;

use Exception::Class (
    'ibackup::Exception' => {
        description => 'Generic base class for all exception of this script'
    },
    'ibackup::Exception::Network' => {
        isa => 'ibackup::Exception',
        description => 'Exception related to network errors (bad subnet etc.)',
        alias => 'network_error',
    },
    );
# ####
# #
# ##
# sub isa_ibackup_exception(@) {
#     my ($err, $name) = @_;
#     return unless defined $err;

#     if ($name) {
#         my $class = "ibackup::Exception::$name";
#         return blessed $err && $err->isa($class);
#     } else {
#         return blessed $err && $err->isa('ibackup::Exception');
#     }
# }



##############################################################################
#     PACKAGE MAIN
##############################################################################
package main;

use strict;
use warnings;

use Exception::Class::TryCatch;

# PATH (/sbin required for mount_afp)
$ENV{'PATH'} = "$ENV{'PATH'}:/bin:/usr/bin:/usr/local/bin:$ENV{'HOME'}/bin:/sbin";

# Generic variables
our $VERSION = '@VERSION@';   # Script version
our $VERBOSE = 1;             # option variable for verbose mode (default: false)
our $DEBUG   = 1;             # option variable for debug mode with default
# value (false)
our $QUIET   = 0;             # By default, display all informations
our $numargs = scalar(@ARGV); # Number of arguments
our $command = `basename $0`; # base command
chomp($command);

# Specific variables
our $SIMULATION_MODE = 0;    # By default, don't simulate
our $SYNC_MODE       = "--update"; # By default, update directories, don't delete
# obsolete files
our $HISTORICAL      = 0;    # By default do not keep an history of older backups
our $MAC_FORK        = 0;    # option variable for Mac OS resource forks with
# default value (false)
our $NOTIFICATION    = 0;    # By default, don't use system user notification feature
our $RETRIEVE_MODE   = 0;    # By default, push data on the backup target and
# don't retrieve anything
our $PRE_SCRIPT;             # Complete path to pre-backup script
our $POST_SCRIPT;            # Complete path to post-backup script

our $config_file;            # Configuration file.
our @backup_sections;        # backup sections to be used in the configuration file
our @OS = qx(uname);         # Current OS





#log::initialize("/tmp/logtest/", 'Sebastien.Varrette@uni.lu');
#log::initialize('Sebastien.Varrette@uni.lu');

# Initialize the logs
#log::initialize("/tmp/losssgtest");
log::initialize();

print::debug("debug");
print::info(" info");
print::warn("Warning");
print::error("My error");

print::notification('Title', "msg");

print::debug("IP found: ", system::getIPFromInterface());

#try
eval {
    system::check_subnet('192.168');
};
# catch
if ( catch my $err ) {
    if ($err->isa('ibackup::Exception::Network')) {
        print::warn("Network exception: ", $err->error, "\n");
    } else {
        # not recoverable
        print::warn "Unrecoverable error: $err\n";
        $err->rethrow;
    }
}

# my $e = $@;
# print "e = $e\n";
# if ($e = ibackup::Exception::isa_ibackup_exception($e, 'Network')) {
#     print::warn("Catch exception: ", $e->error, "\n", $e->trace->as_string, "\n");
#     print::warn(join ' ', $e->euid, $e->egid, $e->uid, $e->gid, $e->pid, $e->time);
# } else {
#     print::error("Unknown exception");
#     $e = Exception::Class->caught();
#     ref $e ? $e->rethrow : die $e;
# }
