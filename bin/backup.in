#!@PERL@ -w

##############################################################################
# File   : backup
# Author : Sebastien VARRETTE <Sebastien.Varrette@uni.lu>
# 05 Jan 2009
#
# Description : A script for handling backups of your system 
#               See the man page for more information.
#
# Copyright (c) 2009 Sebastien Varrette  (http://varrette.gforge.uni.lu/)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Sebastien Varrette                               \n
# <Sebastien.Varrette@uni.lu>                      \n
# University of Luxembourg                         \n
# 6, rue Richard Coudenhove-Kalergi                \n
# L-1359 Luxembourg                                \n
##############################################################################
use strict;
use warnings;

# Used packages
use Switch;
use Storable qw(dclone);      # for recursive copy of nested hash 
use Hash::Util qw{lock_hash}; # To be able to lock keys/values in hash tables
use Time::localtime;          # To access local time
use POSIX qw(strftime);       # To format time 
use Getopt::Long;             # For command line management (long version)
use Config::General;          # For configuration file parsing
use Term::ANSIColor;          # To send the ANSI color-change sequences to the user's terminal
use Data::Dumper;
use Pod::Usage;

# Generic variables
my $VERSION = '@VERSION@';            # Script version
my $VERBOSE = 0;              # option variable for verbose mode with default value (false)
my $DEBUG   = 0;              # option variable for debug mode with default value (false)
my $QUIET   = 0;              # By default, display all informations
my $numargs = scalar(@ARGV);  # Number of arguments
my $command = `basename $0`;  # base command
chomp($command);

# Specific variables
my $SIMULATION_MODE = 0;          # By default, don't simulate
my $SYNC_MODE       = "--update"; # By default, update directories, don't delete obsolete files
my $RETRIEVE_MODE   = 0;          # By default, push data on the backup target and don't retrieve anything

my $config_file;                  # Configuration file.
my @backup_sections;                     # backup sections to be used in the configuration file 

my %SETTINGS = (
		'use_duplicity'         => 'no', 
		'log_file'              => undef,
		'patternfile_exclude'   => undef,
		'restrict_on_subnet'    => undef,
		'src_rootdir'           => '/',
		'dst_rootdir'           => '/',
		'include_dir'           => undef,
		'exclude_dir'           => undef,
		'exclude_dir_exception' => undef,
		'Directory'             => undef,
		'target_url'            => undef,
	       );

my %BACKUP_CMD_INFO = (
		       'basecmd'     => 'rsync',
		       'opt'         => '',
		       'src'         => undef,
		       'dst'         => undef,
		       'dirs'        => undef,
		       'proto'       => undef,
		       'port'        => undef,
		       'target'      => undef,
		      );

my %DEFAULT_SETTINGS        = %SETTINGS;
my %DEFAULT_BACKUP_CMD_INFO = %BACKUP_CMD_INFO;
lock_hash(%DEFAULT_SETTINGS);         # for extra safety
lock_hash(%DEFAULT_BACKUP_CMD_INFO); # for extra safety

# Process command line
my $getoptRes = GetOptions(# Specific options
			   'section=s'       => \@backup_sections,              # sections to consider
			   'config-file|f=s' => \$config_file,                  # Configuration file
			   'dry-run|n'       => \$SIMULATION_MODE,              # Simulation mode
			   'exact_sync|e'    => sub { 
			       warning("This option force an exact duplication and can lead to deletion of files.\n");
			       really_continue() unless $QUIET;
			       $SYNC_MODE="--delete"; 
			   }, 
			   'push|p'          => sub { $RETRIEVE_MODE = 0},      # push data on the backup target
			   'restore|retrieve|r' => sub { $RETRIEVE_MODE = 1},   # restore data from the backup
			   # Generic (classical) options
			   'verbose|v' => \$VERBOSE,                            # Verbose mode
			   'quiet|q'   => \$QUIET,                              # Quiet mode
			   'debug'     => sub { $DEBUG = 1; $VERBOSE = 1; },    # Debug mode
			   'help|h'    => sub { pod2usage(-exitval => 1,
							  -verbose => 2); },    # Show help
			   'version'   => sub { VERSION_MESSAGE(); exit(0); }   # Show version
			  );

PRINT_ERROR_THEN_EXIT("check the format of the command-line") unless ($getoptRes);
if ($QUIET && $RETRIEVE_MODE) {
    $QUIET = 0;
    info("Quiet mode desactivated when retrieving data\n");
}

# Process configuration file
unless ($config_file) {
    my @conffile_list = ('/etc/backup.conf', "$ENV{HOME}/.backup.conf");
    # if no configuration file found in the command-line arguments, check successively for files listed 
    # in @conffile_list
    foreach my $f  (@conffile_list) {
	$config_file = $f if (-e $f);
    }
    PRINT_ERROR_THEN_EXIT("No configuration file found among @conffile_list") unless ($config_file);
}
verbose("=> Configuration file : $config_file\n");
my %CONFIGS = Config::General::ParseConfig(-ConfigFile => $config_file, 
					   -InterPolateEnv => 1);

PRINT_ERROR_THEN_EXIT("Empty configuration") unless (%CONFIGS);


lock_hash(%CONFIGS);
debug("Creation of the hash table from the configuration file $config_file : \n");
debug(Dumper \%CONFIGS); 

# I allow comma-separated backup_sections: --sections=toto,tutu is equivalent to --sections=toto --sections=tutu
@backup_sections = split(/,/,join(',',@backup_sections));
@backup_sections = ('default') unless (@backup_sections);
debug("Backup section(s) to consider in the configuration file : @backup_sections\n");
# Check configuration file format : you should have a section 'global' + one for each backup config asked
ensure_section_exists('global', @backup_sections);

# proceed with each section 
foreach my $sec (@backup_sections) {
    info('Proceeding backup configured in section ' . color('bold') . "$sec" . color('reset') . "\n");
    # get the settings for this synchro
    debug("Add global settings\n");
    restore_global_settings();
    debug("Append specific settings from section $sec\n");
    update_settings_from($CONFIGS{$sec});
    print_current_settings();
    ensure_defined_settings('src_rootdir', 'dst_rootdir', 'include_dir', 'target_url');
    
    # configure the command to be executed
    configure_sync_cmd();
    
    # run the command
    run_sync_cmd();
}

#################################################################################
############## ------------------ Sub routines  ------------------ ##############
#################################################################################

######
# Print information in the following form: '[$2] $1' ($2='=>' if not submitted)
# usage: info(text [,title])
##
sub info {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    my $prefix = $_[1] ? $_[1] : '=>';
    print "$prefix $_[0]" unless $QUIET;
}

######
# Print verbose information (i.e print only if $VERBOSE is set)
# usage: verbose(text)
##
sub verbose {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    print @_ if ${VERBOSE};
}

######
# Print debug information (i.e print only if $DEBUG is set)
# usage: debug(text)
##
sub debug {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    info(@_, '['. color("yellow") . 'DEBUG' . color("reset") . ']') if ${DEBUG};
}

######
# Print error message 
# usage: error(text)
##
sub error {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    info(@_, '['. color("red") . 'ERROR' . color("reset") . ']');
}

######
# Print warning message 
# usage: warning(text)
##
sub warning {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    info(@_, '['. color("magenta") . 'WARNING' . color("reset") . ']');
}

######
# Ask the user is he/she wish to continue. 
##
sub really_continue {
    print "Are you sure you want to continue? [yN] ";
    chomp(my $ans = <STDIN>);
    exit(0) unless ($ans && ($ans =~ /y|yes|1/i));
}

####
# print the settings hash table
##
sub print_current_settings {
    debug("============= Current settings =============\n");
    debug(Dumper \%SETTINGS);
}

sub print_current_cmd_info {
    debug("============= Current backup cmd info =============\n");
    debug(Dumper \%BACKUP_CMD_INFO);
}
####
# Print error message then exit with error status
# Optionnal parameter $_[0] : error message ('Bad format' by defaut) 
##
sub PRINT_ERROR_THEN_EXIT {
    my $msg = $_[0] ? $_[0] : 'Bad format';
    error "$msg\n";
    exit(1);
}

#####
# execute a local command 
# usage: execute(command)
###
sub execute {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    debug('[' . (caller(0))[3] . "] @_\n");
    $SIMULATION_MODE ? 
      print '(', color('bold'), 'simulation', color('reset'), ") @_\n" : system("@_");  
    my $exit_status = $?;
    debug('[' . (caller(0))[3] . "] exit status : $exit_status\n");
    return $exit_status;
}

#####
# execute a command on a remote server by ssh 
# usage: ssh_remote_execute("user@host", port, "command")
###
sub ssh_remote_execute {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] malformed arguments') unless (scalar(@_) >= 3);
    my ($host, $port, @command) = @_;
    my $cmd = "ssh -p $port $host @command 1>/dev/null";
    return execute($cmd);
}

####
# check the presence of the binaries @_ on the local system using 'which'
# usage:  check_binary(bin1 [, bin2 ...]);
##
sub check_binary {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    my $which = "$ENV{'PATH'} which";
    foreach my $app (@_) {
	verbose("=> check availability of the command '$app' on the local system...");
	verbose("\n") if (($DEBUG) || ($SIMULATION_MODE));
       	my $exit_status = execute("which $app 1>/dev/null");
	PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . "] unable to find the application $app on your system") if ($exit_status);
	verbose("\tOK\n");
    }
}

####
# Append the text prefixed by [dd/mm/yy-hh:mm:ss] to the log file defined as $SETTINGS{'log_file'}. 
# if $SETTINGS{'log_file'} is not defined, then the log message is printed on STDERR
# usage : 
##
sub append_to_log {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    my $output;
    if (defined($SETTINGS{'log_file'})) {
	open($output, ">>", $SETTINGS{'log_file'});
    } else {
	$output = *STDERR;
	print $output '[' . color('yellow') . "LOG" . color('reset') . ']';
    }
    my $tm = localtime;
    printf($output "[%04d-%02d-%02d %02dh%02d:%02d] @_\n",
	   $tm->year + 1900,
	   $tm->mon + 1,
	   $tm->mday,
	   $tm->hour, 
	   $tm->min,
	   $tm->sec);
    close($output) if defined($SETTINGS{'log_file'});
}

######
# get current IPs adresses using ifconfig. 
# return an hash table associating an interface name with an IP and a state (up or down)
##
sub getIPs {
    my $interface;
    my %IPs;
    foreach ( qx{ (LC_ALL=C /sbin/ifconfig -a 2>&1) } ) {
        $interface = $1 if /^(\S+?):?\s/;
        next unless defined $interface;
        $IPs{$interface}->{STATE}=uc($1) if /\b(up|down)\b/i;
        $IPs{$interface}->{IP}=$1 if /inet\D+(\d+\.\d+\.\d+\.\d+)/i;
    }
    return %IPs;
}

######
# get current IP adresses associated with an interface. 
# If the interface parameter is not procided, the checked interfaces ar e (eth0, eth1) on Linux system 
# and (en0, en1) on BSD-like. 
# usage: getIPFromInterface(interface) 
##
sub getIPFromInterface {
    my %IPs = getIPs();
    my @interfaces;
    if (@_) {
	@interfaces = ($_[0]);
    } else {
	my @os = qx(uname);
	@interfaces = ('eth0', 'eth1') if ($os[0] eq "Linux");
	@interfaces = ('en0',  'en1')  if ($os[0] =~ "FreeBSD|OpenBSD|Darwin");
    }
    foreach my $i (@interfaces) {
	return $IPs{$i}->{IP} if $IPs{$i};
    }
    PRINT_ERROR_THEN_EXIT("IP not found for interface(s) @interfaces");
    return;
}

####
# check if the IP associated with an interface match another subnet. 
# If no interface argument is provided, then  
# usage: check_subnet(subnet [, interface])
##
sub check_subnet {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    my $subnet = $_[0];
    my $IP = ($_[1] ? getIPFromInterface($_[1]) : getIPFromInterface());
    verbose("=> check subnet $subnet (current IP address found : $IP)...");
    unless ($IP =~ "$subnet") {
	warning "The IP adress $IP does not belong to the subnet $subnet => no backup to be done\n";
	exit 2;
    }
    verbose("\t OK\n")
}

####
# check the existence of a given section in the configuration file
# usage: ensure_section_exists('section_name')
##
sub ensure_section_exists {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    foreach my $sec (@_) {
	PRINT_ERROR_THEN_EXIT("The section $sec cannot be found in the configuration file and is required (man backup.conf for more info)") unless exists($CONFIGS{$sec});
    }
}

####
# ensure the fields in @_ are undefined in %SETTINGS
# usage: ensure_undefined_settings('field')
##
sub ensure_undefined_settings {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    foreach my $field (@_) {
	PRINT_ERROR_THEN_EXIT("The directive $field is defined in the settings yet it should be unitialized at this step") if defined($SETTINGS{$field});
    }
}

####
# check defined field in %SETTINGS
# usage: ensure_defined_settings('field')
##
sub ensure_defined_settings {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    foreach my $field (@_) {
	PRINT_ERROR_THEN_EXIT("The directive $field is mandatory yet undefined in your configuration") unless defined($SETTINGS{$field});
    }
}

#####
# check the availability of the command rsync on the local machine and on the remote backup server
###
sub check_rsync_availability {
    # first check rsync on the local system
    check_binary('rsync');
    if ($BACKUP_CMD_INFO{'proto'} eq 'ssh') {
	verbose("=> check availability of the command 'rsync' on $BACKUP_CMD_INFO{'target'}...");	
	verbose("\n") if ($DEBUG || $SIMULATION_MODE);
	my $exit_status = ssh_remote_execute($BACKUP_CMD_INFO{'target'}, $BACKUP_CMD_INFO{'port'}, "which rsync");
	PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . "] unable to find the application 'rsync' on $BACKUP_CMD_INFO{'target'}") if ($exit_status);
	verbose("\tOK\n");
    }
}

####
# Update the global variable from a hash table passed as arguments (typically a subsection from %CONFIGS)
# usage: update_settings_from(hash_table)
##
sub update_settings_from {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    my %subsection = %{ dclone($_[0])};   # deep copy 
    while (my ($key, $val) = each(%subsection)) {
	if ($key eq 'ssh_auth_sock') { 
	    $ENV{SSH_AUTH_SOCK} = $subsection{'ssh_auth_sock'};
	    debug "Setting the environment variable SSH_AUTH_SOCK to $subsection{'ssh_auth_sock'}\n";
	    next;
	} 
	if (($key eq 'Directory') && defined($SETTINGS{$key})) {
	    # Here we need to append the directories definitions
	    while( my ($dir, $dir_setting) = each(%{$subsection{$key}})) {
		$SETTINGS{$key}->{$dir} = $dir_setting;
	    }
	    next;
	}
	if (exists($SETTINGS{$key})) {
	    $SETTINGS{$key} = $val;
	} else {
	    PRINT_ERROR_THEN_EXIT("The directive $key is not recognized\n");
	}
    }
}

####
# reset the settings
##
sub reset_settings {
    %SETTINGS        = %DEFAULT_SETTINGS;
    %BACKUP_CMD_INFO = %DEFAULT_BACKUP_CMD_INFO; 
}

####
# restore the settings from the global section
##
sub restore_global_settings {
    reset_settings();
    update_settings_from($CONFIGS{'global'});
}

####
# configure the synchronization once the settings are finalized
##
sub configure_sync_cmd {
    if ($SETTINGS{'use_duplicity'} =~ /1|y|yes/i) {
	PRINT_ERROR_THEN_EXIT("The use of duplicity is not yet supported");
    }
    # setup  source basedir (always on the local machine)
    setup_backup_cmd_info_src();
    # setup destination basedir
    info("analysing target url $SETTINGS{'target_url'}\n", "   -");    
    parse_target_url();
    # setup directories to backup/restore
    info("setup local directories to " . ($RETRIEVE_MODE ? "restore" : "backup") . "\n", "   -");
    setup_directories_to_sync();
    verbose("\tfound:  @{$BACKUP_CMD_INFO{'dirs'}}\n");
    # Check command availability both locally and on the target
    check_rsync_availability unless ($QUIET);
    # add options
    treat_cmd_options();
    print_current_cmd_info();
}

####
# run the synchronization command
##
sub run_sync_cmd {
    # First check subnet
    check_subnet($SETTINGS{'restrict_on_subnet'}) if ($SETTINGS{'restrict_on_subnet'});
    if ($RETRIEVE_MODE) {
	warning('You are about to '. color('red') . color('bold') . 'retrieve ' .color('reset') . color('reset') . 
	        "the directories '@{$BACKUP_CMD_INFO{'dirs'}}' from $BACKUP_CMD_INFO{'target'}\n");
	warning("This will " . color('red') . color('bold') . 'overwrite files on your local system.' .color('reset').color('reset') . "\n");
	really_continue() unless $QUIET;
    } else {
	warning("Your are about to backup the directories '@{$BACKUP_CMD_INFO{'dirs'}}' on $BACKUP_CMD_INFO{'target'}.\n") unless $QUIET;
	really_continue() unless $QUIET;
	# create basedir on target
	create_dir_on_target("$BACKUP_CMD_INFO{'dst'}/$BACKUP_CMD_INFO{'src'}") unless $RETRIEVE_MODE;
    }
    
    foreach my $dir (@{$BACKUP_CMD_INFO{'dirs'}}) {
	info("proceeding directory " . color('bold') . "$dir" . color('reset') . "\n", "   ---->");
	my $src_basedir = "$BACKUP_CMD_INFO{'src'}";
	my $dst_basedir = "$BACKUP_CMD_INFO{'dst'}/$BACKUP_CMD_INFO{'src'}";
	my ($src_dir, $dst_dir) = ($dir, $dir);
	# Manage special treatment of the directory
	if (exists($SETTINGS{'Directory'}->{$dir})) {
	    # First interpret included commands
	    foreach my $directive (keys %{$SETTINGS{'Directory'}->{$dir}}) {
		$SETTINGS{'Directory'}->{$dir}->{$directive} = interpret_cmd("$SETTINGS{'Directory'}->{$dir}->{$directive}");
	    }
	    verbose("   using special settings : \n");
	    verbose("   " . Dumper $SETTINGS{'Directory'}->{$dir});
	    $dst_basedir = "$BACKUP_CMD_INFO{'target'}/$SETTINGS{'Directory'}->{$dir}->{'dst_rootdir'}" if $SETTINGS{'Directory'}->{$dir}->{'dst_rootdir'};
	    if ((! $RETRIEVE_MODE) && 
		($SETTINGS{'Directory'}->{$dir}->{'src_in_subfolder'})) 
	      {
		  verbose("=> setup src differentiation for the directory $dir on the target $BACKUP_CMD_INFO{'target'}\n");
		  $dst_basedir .= "/$dir"; 
		  # create directory on target 
		  create_dir_on_target("$dst_basedir");
		  $dst_dir = $SETTINGS{'Directory'}->{$dir}->{'src_in_subfolder'};
	      }
	}
	unless  (($RETRIEVE_MODE) || (-d "$src_basedir/$src_dir")) {
	    # check existence of src dir
	    warning("The source directory '$src_basedir/$src_dir' does not exist => skipping $dir\n");
	    next;
	}
	# Inverse src_basedir and dst_basedir if $RETRIEVE_MODE
	($src_basedir, $dst_basedir) = ($dst_basedir, $src_basedir) if ($RETRIEVE_MODE);

	my $cmd = "$BACKUP_CMD_INFO{'basecmd'} $BACKUP_CMD_INFO{'opt'} $src_basedir/$src_dir/ $dst_basedir/$dst_dir";
	append_to_log("$cmd");
	execute($cmd);
    }

}

####
# specialize the command options
##
sub treat_cmd_options {
    # Treat patternfile_exclude
    if (defined($SETTINGS{'patternfile_exclude'})) {
	if (-f $SETTINGS{'patternfile_exclude'}) {
	    $BACKUP_CMD_INFO{'opt'} .= " --exclude-from=$SETTINGS{'patternfile_exclude'}";
	} else {
	    warning("The pattern file for exclusion $SETTINGS{'patternfile_exclude'} does not exists and will be ignored\n");
	}
    }
    # Add classical options
    $BACKUP_CMD_INFO{'opt'} .= " -avz";
    # TODO: add -E if supported 
#    $BACKUP_CMD_INFO{'opt'} .= " --progress" if $VERBOSE;
    $BACKUP_CMD_INFO{'opt'} .= " --quiet"    if $QUIET;
    $BACKUP_CMD_INFO{'opt'} .= " $SYNC_MODE";    
}


####
# initialize $BACKUP_CMD_INFO{'src'} (i.e the basedir of the local folders to backup) to
# $SETTINGS{'src_rootdir'}, ensuring this directory exists
###
sub setup_backup_cmd_info_src {
    my $src_rootdir = interpret_cmd($SETTINGS{'src_rootdir'});
    PRINT_ERROR_THEN_EXIT("The directory $src_rootdir cannot be found on this computer") unless ( -d $src_rootdir);
    $BACKUP_CMD_INFO{'src'} = $src_rootdir;
}

####
# interpret commands delimited by ` ` in a string. 
# Return the string where `cmd` is replaced by the result of the command 
# usage: interpret_cmd("string")
##
sub interpret_cmd {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    my $string = $_[0]; 
    my @commands = $string =~ /`([^`]+)`/g; # retrieve commands to interpret
    foreach my $cmd (@commands) {
	my $cmd_exec = `$cmd` || die "Unable to execute $cmd : $!\n";
	chomp($cmd_exec);
	$string =~ s/`$cmd`/$cmd_exec/;
    }
    return $string;
}

####
# Parse the target url 
##
sub parse_target_url {
    PRINT_ERROR_THEN_EXIT("Undefined target url") if ! defined($SETTINGS{'target_url'});
    $SETTINGS{'target_url'} = interpret_cmd("$SETTINGS{'target_url'}");
    $SETTINGS{'target_url'} =~ /^\b(\w+):\/\/(([\w\/]+)((\@([\w\.]+))(:(\d+))?)?)/;
    my ($proto, $target, $user, $server, $port) = ($1, $2, $3, $6, $8);
    #my ($proto, $target) = split('://', $SETTINGS{'target_url'});
    debug("Protocol: $proto\n")  if ($proto);
    debug("target  : $target\n") if ($target);
    debug("user    : $user\n")   if ($user);
    debug("server  : $server\n") if ($server);
    debug("port    : $port\n")   if ($port);
    PRINT_ERROR_THEN_EXIT("Malformed url $SETTINGS{'target_url'}") unless ($proto && $target);
    $BACKUP_CMD_INFO{'proto'} = $proto;
    $BACKUP_CMD_INFO{'target'} = $target;
    switch ($proto) {
	case 'drive' { verbose("\tsetup target on the external drive $target\n"); 
		       setup_target_drive($target);
		     }
	case 'file'  { verbose("\tsetup target on the local directory $target\n"); 
		       setup_target_drive($target);
		     }
	case 'ssh'   { PRINT_ERROR_THEN_EXIT("Malformed ssh target") unless ($user && $server);
		       $port = 22 unless ($port);
		       verbose("\tsetup target on the remote server $server.\n");
		       verbose("\tConnection to be established for the remote user $user by ssh on port $port\n"); 
		       setup_target_ssh($user, $server, $port);
		     }
	  else { PRINT_ERROR_THEN_EXIT("The protocol $proto is not supported"); }
    }
}

###
# setup the command for a backup on an external drive or a local directory
# usage: setup_target_drive(path)
##
sub setup_target_drive {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    $BACKUP_CMD_INFO{'dst'} = interpret_cmd($_[0]);
    PRINT_ERROR_THEN_EXIT("The target $BACKUP_CMD_INFO{'dst'} cannot be found") unless ( -d "$BACKUP_CMD_INFO{'dst'}");
}

###
# setup the command for a backup on a remote server reacheable by ssh 
# usage: setup_target_drive(user, server, ssh_port)
##
sub setup_target_ssh {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (scalar(@_) == 3);
    my ($user, $server, $port) = @_;
    $BACKUP_CMD_INFO{'port'}   = $port;
    $BACKUP_CMD_INFO{'target'} = "$user" . '@' . "$server";
    if ($BACKUP_CMD_INFO{'basecmd'} eq 'rsync') {
	$BACKUP_CMD_INFO{'opt'} .= "--rsh=" . (($port == 22) ? "ssh" : "'ssh -p $port'");
	$BACKUP_CMD_INFO{'dst'} = "$user" . '@' . "$server:" . interpret_cmd($SETTINGS{'dst_rootdir'});
    } else {
	PRINT_ERROR_THEN_EXIT("rsync is the only supported command currently");
    }
 #   ssh_remote_execute($BACKUP_CMD_INFO{'target'}, $port, "hostname") || 
  #    die "unable to connect by ssh to $BACKUP_CMD_INFO{'target'} (port $port): $!\n";
}

####
# construct difference between two arrays @A and @B i.e 
# elements elements in @A that are not in @B
# usage: array_diff(\@A, \@B);
##
sub array_diff {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] wrong argument number') unless (scalar(@_) == 2);
    my $a_ref = $_[0];
    my $b_ref = $_[1];
    my %seen = ();      # lookup table
    my @res = ();       # initialize the final receip
    @seen{@{$b_ref}} = (); # build lookup table
    foreach my $item (@{$a_ref}) {
	push(@res, $item) unless exists $seen{$item};
    }
    return @res;
}

####
# create the appropriate dirs field from $BACKUP_CMD_INFO using 
# $SETTINGS{'include_dir'} and $SETTINGS{'exclude_dir'}
# The '*' wildcard is used relatively to $SETTINGS{'src_rootdir'}
###
sub setup_directories_to_sync {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . "] \$BACKUP_CMD_INFO{'dirs'} already defined to $BACKUP_CMD_INFO{'dirs'}") if defined($BACKUP_CMD_INFO{'dirs'});
    # ensure $SETTINGS{'include_dir'} is defined
    ensure_defined_settings('include_dir'); 
    
    my @include_dir = expand_wildcard_dirs($SETTINGS{'include_dir'}, $SETTINGS{'src_rootdir'});
    if (defined($SETTINGS{'exclude_dir'})) {
	my @exclude_dir = expand_wildcard_dirs($SETTINGS{'exclude_dir'}, 
					       $SETTINGS{'src_rootdir'});
	if (defined($SETTINGS{'exclude_dir_exception'})) {
	    my @exclude_dir_exception = expand_wildcard_dirs($SETTINGS{'exclude_dir_exception'},
							     $SETTINGS{'src_rootdir'});
	    @exclude_dir = array_diff(\@exclude_dir, \@exclude_dir_exception);
	}
	@include_dir = array_diff(\@include_dir, \@exclude_dir);
    }
    # populate final receipt for the directories to backup
    $BACKUP_CMD_INFO{'dirs'} = dclone \@include_dir;
}

####
# create the physical directory on the target (depends on the considered protocol)
##
sub create_dir_on_target {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing directory argument') unless (@_);
    foreach my $dir (@_) {
	info("creating directory $dir\n", "    ");
	my $exit_status;
	switch ($BACKUP_CMD_INFO{'proto'}) {
	    case /drive|file/ { execute("mkdir -p $dir"); 
				$exit_status = $?;
			      }
	    case 'ssh'        { my $target = "$BACKUP_CMD_INFO{'target'}:";
				$target =~ s/\@/\\\@/g;
				$dir =~ s/^$target//;
				# now run the command on the server
				ssh_remote_execute($BACKUP_CMD_INFO{'target'}, 
						   $BACKUP_CMD_INFO{'port'},
						   "mkdir -p $dir");
			       $exit_status = $?;
			      }
	      else { PRINT_ERROR_THEN_EXIT("Protocol not supported"); }
	}
	PRINT_ERROR_THEN_EXIT("Unable to create the directory $dir") if ($exit_status);
    }
}


####
# expand the wildcards present in a string containing a space separated list of directories
# usage: expand_wildcard_dirs("list of dirs", "root_dir");
##
sub expand_wildcard_dirs {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] wrong argument number') unless (scalar(@_) == 2);
    my @dirs = split(/\s+/, $_[0]);
    return @dirs if ($_[0] !~ /\*/);

    my $rootdir = $_[1];
    my @res = ();
#    for my $index (0 .. scalar(@dirs)-1) {
    for my $index (0 .. @dirs-1) {
	my $dir = $dirs[$index];
	if ($dir !~  /\*|\^|\$/) {
	    push(@res, $dir);
	    next;
	} else {
	    my $pattern = $dir;
	    opendir(DIR, $rootdir) || die "Couldn't open $rootdir : $!\n";
	    $pattern =~ s/\./\\\./g;   # proceed with the '.' characters
	    $pattern =~ s/\*/\.\*/g;   # proceed with the '*' characters
	    my @expanded_dir = map { $_->[0] }                # extract subdir name
		               grep { -d $_->[1] }            # check absolute path is a dir
			       map  { [ $_, "$rootdir/$_" ] } # create name, absolute path
			       grep { !/^\.\.$/}              # filter out .. entry
			       grep { !/^\.$/}                # filter out . entry
			       grep { /$pattern/ }            # apply pattern filter
				 readdir(DIR);
	    closedir(DIR);
	    #debug("The pattern " . color('bold') . "$dir" . color("reset") . " relative to $rootdir has been expanded to : "  . color('bold') . "@expanded_dir" . color("reset") . "\n");
	    push(@res, @expanded_dir);
	}
    }
    return @res;
}

####
# Print script version
##
sub VERSION_MESSAGE {
    print <<EOF;
This is $command v$VERSION.
Copyright (c) 2009 Sebastien Varrette  (http://www-id.imag.fr/~svarrett/)
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
}

######################## POD documentation ########################
=pod

=head1 NAME

I<backup>, a highly flexible script utility to backup directories from your local 
system on various targets (external drive, remote server with SSH access etc.)

I<backup> relies for that on B<rsync> (see L<http://samba.anu.edu.au/rsync/>) and 
(in a future release) B<duplicity> (see L<http://duplicity.nongnu.org/>) together with a 
configuration file.

=head1 SYNOPSIS

      ./backup [options] 

=head1 DESCRIPTION

I<backup> rely on a configuration file to describe the characteristics of a backup to be 
performed (files to include/exclude, target url etc. -- see L<CONFIGURATION FILE FORMAT> 
for more details). Here is a illustrative examples: 

    # Configuration file example
    #
    #### Mandatory global settings #### 
    <global>
         src_rootdir = $HOME     # Root directory on the (local) source
         include_dir = *         # backup all sub-directories (relative to src_rootdir)
    </global>

    #### Mandatory default backup definition ####
    <default>
         target_url = drive:///Volume/Backup  # backup on an external drive 'Backup'
    </default>

    # Definition of the backup on the server 'toto'
    <toto>
         target_url  = ssh://mylogin@toto.example.org  # backup through ssh
         dst_rootdir = /backup/`whoami`@`hostname`     # Root directory on target server
         restrict_on_subnet = 192.168  # backup only when your machine belongs to this subnet
	# Special treatment of the "Music" subdirectory
	<Directory Music>
		 dst_rootdir = /multimedia  # change the rootdir on target for this folder
	</Directory>
    </toto>

So appart from the 'global' section, each backup is defined in a named block that helps 
to complete and/or overwrite the global settings.
To run the backup configured by default, just run:
 
    ./backup -f /path/to/config_file
  
To run the backup configured by the 'toto' section, just run:

    ./backup -f /path/to/config_file -s=toto

If a configuration file is not passed command-line through the C<-f> option, I<backup>
use by default $HOME/.backup.conf and then /etc/backup.conf.

To restore data from the backup 'toto', run : 

    ./backup -f /path/to/config_file -s=toto -r

=head1 OPTIONS

The following options are available:

=over 12

=item B<--debug>

Debug mode. Display debugging information probably only relevant to me ;)

=item B<--dry-run   -n>

Simulate the operations to show what would have been done and/or transferred but do 
not perform any backend actions.

=item B<--exact-sync  -e>

Exact synchronization mode. 
Causes I<backup> to delete files on the target if absent in the source directory. 
This ensure an exact replica but you may loose files so use this option with caution. 

=item B<--help  -h>

Display a help screen and quit.

=item B<--push -p>

Push mode: push data on the backup target. This is the default behaviour of  I<backup>.

=item B<--quiet>

Quiet mode. Minimize the number of printed messages and don't ask questions. 
Very useful for invoking this script in a crontab yet use with caution has all 
operations will be performed without your interaction.

=item B<--restore  --retrieve  -r>

Retrieve mode: restore data from the backup. Use with caution as this will probably 
overwrite files on your local machine!

=item B<--section=SECTION[, SECTION2 ...]>

=item B<-s=SECTION[, SECTION2 ...]>

Specify the successive sections to use for the backup configuration. 
If this option is not set, I<backup> will use the section B<default>.
Currently, the implementation make the script exits as soon as an error happens 
(wrong subnet, target drive not available etc.) yet future release will just go on the 
next backup section on error which will be helpfull for crontab configuration. 


=item B<--verbose  -v>

Verbose mode. Display more information

=item B<--version>

Display the version number then quit. 

=back

=head1 CONFIGURATION FILE FORMAT

The configuration file for I<backup> is divided into sections defined as blocks.
A block looks much like a block in the wellknown apache config format. 
It starts with C<< <blockname> >> and ends with C<< </blockname> >>

Two sections are mandatory: 'global' (which define global settings for the backup) and 
'default' (which refer to the default backup configuration). 
Each additionnal section is considered as a separate backup configuration and can be 
refered using the command-line option C<-s> (see L<DESCRIPTION>).

When defining directory lists, you may use the following patterns symbols: 
the wildcard C<*>, the symbol C<^> to specify the begining
of a name and the symbol C<$> to refer to its end.
For instance, you can use the following patterns: 

=over 4

=item * C<*> : all sub-directories (including the hidden one that starts with '.')

=item * C<^AR*> : all subdirectories whose name starts by AR

=item * C<*ES$> : all subdirectories whose name ends by ES

=item * C<^.*>  : all hidden directories (the one that starts by '.')

=back

The following directives are recognized: 

=over 8

=item B<< <Directory DIR> ... </Directory> >>

This directive makes it possible to specialize the behaviour of I<backup> for the 
directory DIR. You may overwrite the following options  

=over 4

=item * B<dst_rootdir = ROOTDIR> : see C<dst_rootdir>

=item * B<src_in_subfolder = SUBDIR> : this sub section is used to separate on the target 
the files and subfolders in DIR into a subdirectory named 'SUBDIR'. 
For instance, let assume one want to synchronize the B<$HOME/.ssh> folder from 
multiples computers B<comp1>, B<comp2> etc. on the server B<target_server>, each computer 
running the I<backup> script. 
Unless any special behaviour, the files B<$HOME/.ssh/id_dsa*> will be overwritted on 
B<target_server> every time the script is invoked on the computers. 
On the other hand, assuming we have set the B<src_in_subfolder> directive as follow: 

      <Directory .ssh>
          src_in_subfolder = `hostname`
      </Directory>

Then the B<$dst_rootdir/$HOME/.ssh> folder on the target server B<target_server> will 
contain subfolders B<comp1>, B<comp2> etc., each containing the files and subdirs of
B<$HOME/.ssh/> from the source computer. 

This directive is ignored in retrieve mode (see option C<-r>)

=back

=item B<dst_rootdir = ROOTDIR>

Root directory on the backup target (C</> by default)

=item B<exclude_dir = PATTERN1 [PATTERN2] [PATTERN3]...>

Space separated list of directories to exclude from synchronization (relative to B<$src_rootdir>).
You may use the pattern symbols C<*>, C<^> and C<$> for each element of the list. 

=item B<exclude_dir_exception = PATTERN1 [PATTERN2] [PATTERN3]...>

Add exceptions to B<exclude_dir> (nice if wildcards have been used)
You may use the pattern symbols C<*>, C<^> and C<$> for each element of the list. 

=item B<include_dir = PATTERN1 [PATTERN2] [PATTERN3]...>

Space separated list of directories to include from synchronization (relative to B<$src_rootdir>).
You may use the pattern symbols C<*>, C<^> and C<$> for each element of the list. 

=item B<log_file = FILE>

Set FILE as the log file for I<backup>. If not present, logs are printed on STDERR.

=item B<patternfile_exclude = FILE>

The file containing file patterns that should NOT be synchronized. 
For instance, if you don't want to synchronize the temporary files generated by 
I<emacs> or I<vim>, you should put the following entries in FILE: 

        *~
        #*#
        .#*

=item B<restrict_on_subnet = SUBNET> 

Operate the synchronization only when your machine (i.e the network interface) belongs to the subnet 
SUBNET. The successive network interface checked for an IP compared with SUBNET are: 

=over 4

=item * (eth0, eth1) on  Linux system (obtained by the I<uname> command)

=item * (en0, en1) on FreeBSD, OpenBSD and Darwin systems (which include Mac OS X)

=back

=item B<src_rootdir>

Root directory on the (local) source  (C</> by default)

=item B<ssh_auth_sock = /path/to/ssh-agent.socket>

Set the environment variable B<$SSH_AUTH_SOCK> for this synchronization to the socket 
of the socket file of the ssh-agent instance. 
This is mandatory if you set a passphrase to you SSH key and want the I<backup> script  
to automatically authenticate on a remote server wher you setup an ssh public key 
authentication.

=item B<target_url = URL>

Define the target url of the backup (see L<TARGET URL FORMAT>).

=item B<use_duplicity = yes>

(Not yet supported) use I<duplicity> instead of I<rsync>

=back

=head1 TARGET URL FORMAT

I<backup> tries to maintain a standard URL format for backup targets.  
The generic format for a target URL is:

              protocol://path|user[@host[:port]]

I<backup> don't support the exposure of cleartext passwords on purpose for obvious security 
reasons. 

Current supported protocols include: 

=over 4

=item * C<drive> : an external drive 

Example:  
      drive:///Volumes/MyDrive         (under Mac OS X)
      drive:///mnt/mydrive             (under Linux) 

=item * C<file>  : a local folder

Example: 
      file:///path/to/local/folder

=item * C<ssh>   : SSH with public key authentication 

Example: 
      ssh://mylogin@server1
      ssh://mylogin@server1.example.org
      ssh://mylogin@server2.example.org:8022

Even if public key authentication is not required, it is strongly recommended and 
mandatory if I<backup> should be launched in a crontab for instance. 

To setup public key authentication, please refer to L<http://sial.org/howto/openssh/publickey-auth/> 

=back

=head1 AUTHOR

Sebastien Varrette -- L<http://varrette.gforge.uni.lu/>

Please report bugs to L<Sebastien.Varrette@uni.lu>.

=head1 COPYRIGHT
 
This  is a free software. There is NO warranty; not even for
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


=cut

# POD documentation to be done: 
#Suggested by Damian Conway in Perl Best Practices.
#Name
#Usage
#Description
#Required arguments
#Options
#Exit status
#Diagnostics
#Configuration
#Dependencies
#Incompatibilities
#Bugs and limitations
#Author
#License and copyright
#Disclaimer of warranty

