#!/usr/bin/perl -w
###!@PERL@ -w

##############################################################################
# File   : backup
# Authors: Sebastien VARRETTE     <Sebastien.Varrette@uni.lu>
#          Guillaume-Jean HERBIET <Guillaume.Herbiet@uni.lu>
# $Id$
#
# Description : @PACKAGE_SUMMARY@
#               For more information: see backup(3) or
#               @PACKAGE_WEBSITE@
#
# Copyright (c) 2009 Sebastien Varrette     (http://varrette.gforge.uni.lu/)
#                    Guillaume-Jean Herbiet (http://herbiet.gforge.uni.lu/)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.
#
# Sebastien Varrette     <Sebastien.Varrette@uni.lu>\n
# Guillaume-Jean Herbiet <Guillaume.Herbiet@uni.lu> \n
# University of Luxembourg                          \n
# 6, rue Richard Coudenhove-Kalergi                 \n
# L-1359 Luxembourg                                 \n
##############################################################################

### Function prototype declaration ###
sub print::error_nolog(@);
sub print::error(@);
sub print::debug(@);
sub print::info(@);
sub print::warning(@);
sub print::warn(@);
sub print::critical(@);
sub print::alert(@);
sub print::error_nolog_and_exit($@);
sub print::error_and_exit($@);
sub print::notification($$@);
sub print::really_continue();

sub format::color_msg($$);

sub log::initialize(@);

sub system::execute(@);
sub system::remote_execute_by_ssh($$@);


##############################################################################
# PACKAGE PRINT
# Handle all printing features
##############################################################################
package print;

use strict;
use warnings;
use List::Util qw[min max];   # To find min/max values

#our $print_level = 2;

#######
# Print information in the following form: prefix msg
# usage: print::with_prefix(prefix, msg)
###
sub with_prefix($@) {
    my $prefix = shift;
    print "$prefix @_" unless $::QUIET;
}

#######
# print an error information without passing through the log manager
###
sub error_nolog(@) {
    print::with_prefix('[' . format::color_msg('red', 'ERROR') . ']', @_);
}
#####
# the following functions are called to display an information depending on the
# considered level
##
sub error(@)    { $log::handler->error(@_); }
sub debug(@)    { $log::handler->debug(@_) if $main::DEBUG;   }
sub info(@)     { $log::handler->info(@_);  }
sub verbose(@)  { info(@_) if $main::VERBOSE; }
sub warning(@)  { $log::handler->warn(@_);  }
sub warn(@)     { warning(@_); }
sub critical(@) { $log::handler->crit(@_); }
sub alert(@)    { $log::handler->alert(@_); }

####
# Print error message then exit with exit status $_[0]
##
sub error_nolog_and_exit($@) {
    my $exit_code = shift;
    print::error_nolog(@_);
    exit($exit_code);
}
sub error_and_exit($@) {
    my $exit_code = shift;
    print::error(@_);
    exit($exit_code);
}

######
# Send a graphical notification to the user (using growl under Mac or
# notify-send under Linux)
# usage: notification(title, text [, priority])
##
sub notification($$@) {
    my $title    = shift;
    my $text     = shift;
    my $priority = shift;
    $priority    = defined($priority) ? $priority : 0;
    my $notify_cmd="";

    # Select notification system based on system
    if ($main::OS[0] =~ "Darwin") {           # Mac OS X: use growlnotify
        $priority = max(min($priority, 2), -2);
        $notify_cmd =
            'growlnotify -p ' . $priority .
            ' -n '.$main::command.' -a \'iSync\' \'' . $title . '\' '.
            '-m \''. $text .'\' > /dev/null 2>&1';
    } elsif ($main::OS[0] =~ "Linux") {
        $priority = max(min($priority, 1), -1) +1;
        my @levels = ("low", "normal", "critical");
        $notify_cmd =
            'notify-send -u ' . $levels[$priority] .
            ' -i gtk-dialog-info \'' . $title . '\' \'' . $text . '\'';
    } else {
        print::warning('ibackup do not support graphical notification for the ',
                       $main::OS[0], " OS\n");
    }
    system::execute($notify_cmd);
}

######
# Ask the user is he wishes to continue. 
##
sub really_continue() {
    print "Are you sure you want to continue? [yN] ";
    chomp(my $ans = <STDIN>);
    unless ($ans && ($ans =~ /y|yes|1/i)) {
	#sync::clean_after_sync();
	exit(0);
    }
}


##############################################################################
# PACKAGE FORMAT
# Handle all reformatting features
##############################################################################
package format;

use strict;
use warnings;
use Term::ANSIColor; # To send the ANSI color-change sequences to the user's terminal

#####
# return a colored message (coloration only appens in the terminal typically)
###
sub color_msg($$) {
    my $color = shift;
    my $msg = shift;
    return  Term::ANSIColor::color("$color") . "$msg" . Term::ANSIColor::color("reset");
}

##############################################################################
# PACKAGE LOG
# Handle all logging features
##############################################################################
package log;
use strict;
use warnings;

use Log::Handler;  # Log manager
#
# The following log levels are defined:
#     7   debug
#     6   info
#     5   notice
#     4   warning, warn
#     3   error, err
#     2   critical, crit
#     1   alert
#     0   emergency, emerg
#
# The message layout in the printf style with the following options:
#
#     %L   Log level
#     %T   Time or full timestamp (option timeformat)
#     %D   Date (option dateformat)
#     %P   PID
#     %H   Hostname
#     %U   User name
#     %G   Group name
#     %N   Newline
#     %S   Program name
#     %C   Caller - filename and line number
#     %p   Caller - package name
#     %f   Caller - file name
#     %l   Caller - line number
#     %s   Caller - subroutine name
#     %r   Runtime in seconds since program start
#     %t   Time measurement - replaced with the time since the last call of $log->$level
#     %m   Message
#     %%   Procent

our $handler    = Log::Handler->new();
our $timeformat = '%Y/%m/%d %H:%M:%S';
our $msg_layout = '%T [%L] %m';


########
# Initialize the log handler
# Usage: initialize([logdir],[email])
#        initialize([logdir])
#        initialize([email])
##
sub initialize(@) {
    my ($logdir, $email) = @_;

    # Recognize a mail address instead of a directory as
    if ((scalar(@_) == 1) &&
        ($logdir =~ /\b[\w0-9._%+-]+@(?:[\w0-9-]+\.)+[\w]{2,4}\b/))
    {
        print "First argument is an email: $logdir\n";
        $email  = $logdir;
        $logdir = undef;
    }
    my $yellow_level  = format::color_msg('yellow',  '%L');
    my $magenta_level = format::color_msg('magenta', '%L');
    my $red_level     = format::color_msg('red',     '%L');

    my $debug_msg_layout = my $error_msg_layout = my $warning_msg_layout = $msg_layout;

    # ===  Initialize screen log (in the terminal) ===
    # Redirect debug logs to STDOUT (in yellow)
    $debug_msg_layout =~ s/%L/$yellow_level/g;
    $handler->add(
        screen => {
            log_to   => "STDOUT",
            maxlevel => 7,
            minlevel => 7,
            timeformat      => "$timeformat",
            message_layout  => "$debug_msg_layout",
        }
        );

    # Redirect common logs to STDOUT
    $handler->add(
        screen => {
            log_to   => "STDOUT",
            maxlevel => 6,
            minlevel => 5,
            timeformat      => "$timeformat",
            message_layout  => "$msg_layout",
        }
        );

    # redirect warnings to STDERR
    $warning_msg_layout =~ s/%L/$magenta_level/g;
    $handler->add(
        screen => {
            log_to   => "STDERR",
            maxlevel => 4,
            minlevel => 4,
            timeformat      => "$timeformat",
            message_layout  => "$warning_msg_layout",
        }
        );

    # Redirect errors to STDERR
    $error_msg_layout =~ s/%L/$red_level/g;
    $handler->add(
        screen => {
            log_to   => "STDERR",
            maxlevel => 3,  # error
            minlevel => 0,  # emerg
            timeformat      => "$timeformat",
            message_layout  => "$error_msg_layout",
        }
        );

    # ===  Initialize file log (in $logdir) ===
    if (defined($logdir)) {
        # ensure the directory exists
        print::error_and_exit(1, "The directory $logdir do not exists impossible to log into this directory\n") unless (-d "$logdir");

        # Initialie the log file for common logs
        $handler->add(
            file => {
                filename   => "${logdir}/common.log",
                maxlevel   => 7,  # debug
                minlevel   => 5,  # notice
                timeformat      => "$timeformat",
                message_layout  => "$msg_layout",
            }
            );

        # Initialize the log file for error logs
        $handler->add(
            file => {
                filename => "${logdir}/error.log",
                maxlevel => 4,  # warning
                minlevel => 0,  # emerg
                timeformat      => "$timeformat",
                message_layout  => "$msg_layout",
            }
            );
    }

    if (defined($email)) {
        chomp(my $username = `whoami`);
        chomp(my $hostname = `hostname -f`);
        my $from = $username . '@' . $hostname;
        print::debug("Setup log by mail (from=$from) to $email\n");

        $handler->add(
            sendmail => {
                from     => "${username}\@${hostname}",
                to       => "$email",
                subject  => "(ibackup)",
                maxlevel => 4,
                minlevel => 0,
                message_pattern => '%L',
                timeformat      => "$timeformat",
                message_layout  => "$msg_layout",
            }
            );
    }
}

##############################################################################
# PACKAGE SYSTEM
# Handle all system calls/behaviour etc.
##############################################################################
package system;

use strict;
use warnings;

#####
# execute a local command
# usage: execute(command)
###
sub execute(@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    print::debug('[' . (caller(0))[3] . "] @_\n");
    ($main::SIMULATION_MODE) ?
        print format::color_msg('bold', "@_\n") : system("@_");
    my $exit_status = $?;
    print::debug('[' . (caller(0))[3] . "] exit status : $exit_status\n");
    return $exit_status;
}

#####
# execute a command on a remote server by ssh 
# usage: ssh_remote_execute("user@host", port, "command")
###
sub remote_execute_by_ssh($$@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    my ($host, $port, @command) = @_;
    my $cmd = "ssh -p $port $host @command 1>/dev/null";
    return system::execute($cmd);
}

####
# check the presence of the binaries @_ on the local system using 'which'
# usage:  check_binary(bin1 [, bin2 ...]);
##
sub check_binary(@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    my $which = "$ENV{'PATH'} which";
    foreach my $app (@_) {
	print::verbose("=> check availability of the command '$app' on the local system...");
	verbose("\n") if (($main::DEBUG) || ($main::SIMULATION_MODE));
       	execute("which $app 1>/dev/null") || 
            print::error_and_exit(1, "$app: command not found in PATH=$ENV{'PATH'}");
	verbose("\tOK\n");
    }
}


##############################################################################
#     PACKAGE MAIN
##############################################################################
package main;

use strict;
use warnings;

# PATH (/sbin required for mount_afp)
$ENV{'PATH'} = "$ENV{'PATH'}:/bin:/usr/bin:/usr/local/bin:$ENV{'HOME'}/bin:/sbin";

# Generic variables
our $VERSION = '@VERSION@';   # Script version
our $VERBOSE = 1;             # option variable for verbose mode (default: false)
our $DEBUG   = 1;             # option variable for debug mode with default
# value (false)
our $QUIET   = 0;             # By default, display all informations
our $numargs = scalar(@ARGV); # Number of arguments
our $command = `basename $0`; # base command
chomp($command);

# Specific variables
our $SIMULATION_MODE = 0;    # By default, don't simulate
our $SYNC_MODE       = "--update"; # By default, update directories, don't delete
# obsolete files
our $HISTORICAL      = 0;    # By default do not keep an history of older backups
our $MAC_FORK        = 0;    # option variable for Mac OS resource forks with
# default value (false)
our $NOTIFICATION    = 0;    # By default, don't use system user notification feature
our $RETRIEVE_MODE   = 0;    # By default, push data on the backup target and
# don't retrieve anything
our $PRE_SCRIPT;             # Complete path to pre-backup script
our $POST_SCRIPT;            # Complete path to post-backup script

our $config_file;            # Configuration file.
our @backup_sections;        # backup sections to be used in the configuration file
our @OS = qx(uname);         # Current OS







#log::initialize("/tmp/logtest/", 'Sebastien.Varrette@uni.lu');
#log::initialize('Sebastien.Varrette@uni.lu');

# Initialize the logs
#log::initialize("/tmp/logtest");
log::initialize();

print::debug("debug");
print::info(" info");
print::warn("Warning");
print::error("My error");


print::notification('title', "msg");
