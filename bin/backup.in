#!/usr/bin/perl -w
###!@PERL@ -w

##############################################################################
# File   : backup
# Authors: Sebastien VARRETTE     <Sebastien.Varrette@uni.lu>
#          with contributions by:
#          Guillaume-Jean HERBIET <Guillaume.Herbiet@uni.lu>
# $Id$
#
# Description : @PACKAGE_SUMMARY@
#               For more information: see backup(3) or
#               @PACKAGE_WEBSITE@
#
# Copyright (c) 2009 Sebastien Varrette     (http://varrette.gforge.uni.lu/)
# with contributions by Guillaume-Jean Herbiet (http://herbiet.gforge.uni.lu/)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.
#
# Sebastien Varrette     <Sebastien.Varrette@uni.lu>\n
# Guillaume-Jean Herbiet <Guillaume.Herbiet@uni.lu> \n
# University of Luxembourg                          \n
# 6, rue Richard Coudenhove-Kalergi                 \n
# L-1359 Luxembourg                                 \n
##############################################################################

### Function prototype declaration ###
sub print::alert(@);
sub print::critical(@);
sub print::debug(@);
sub print::error_nolog_and_exit($@);
sub print::error_and_exit($@);
sub print::error_nolog(@);
sub print::error(@);
sub print::info(@);
sub print::notification($$@);
sub print::really_continue();
sub print::version();
sub print::warning(@);
sub print::warn(@);
sub print::hash_content($@);

sub sync::set_backup_target_to_drive($);
sub sync::set_cmd();
sub sync::parse_target_url();


sub config::ensure_profile_set(@);
sub config::getPasswordFromFile($$);
sub config::getPasswordForEntry($);
sub config::reset_settings();
sub config::set_profile($);

sub format::color_msg($@);
sub format::interpret_cmd($);

sub hash::has_keys($@);

sub log::initialize(@);

sub system::check_binary(@);
sub system::check_subnet($@);
sub system::execute(@);
sub system::getIPs();
sub system::getIPFromInterface(@);
sub system::has_directory(@);
sub system::mount_encfs($$@);
sub system::remote_execute_by_ssh($$@);


##############################################################################
# PACKAGE PRINT
# Handle all printing features
##############################################################################
package print;

use strict;
use warnings;
use List::Util qw[min max];     # To find min/max values
use Term::ANSIColor;            # To send the ANSI color-change sequences to the
                                # user's terminal
use Data::Dumper;


#our $print_level = 2;

#######
# Print information in the following form: prefix msg
# usage: print::with_prefix(prefix, msg)
###
sub with_prefix($@) {
    my $prefix = shift;
    print "$prefix @_" unless $config::QUIET;
}

#######
# print an error information without passing through the log manager
###
sub error_nolog(@) {
    print::with_prefix('[' . format::color_msg('red', 'ERROR') . ']', @_);
}
#####
# the following functions are called to display an information depending on the
# considered level
##
sub error(@)    { $log::handler->error(@_); }
sub debug(@)    { $log::handler->debug(@_) if $config::DEBUG;   }
sub info(@)     { $log::handler->info(@_);  }
sub verbose(@)  { info(@_) if $config::VERBOSE; }
sub warning(@)  { $log::handler->warn(@_);  }
sub warn(@)     { warning(@_); }
sub critical(@) { $log::handler->crit(@_); }
sub alert(@)    { $log::handler->alert(@_); }

####
# Print error message then exit with exit status $_[0]
##
sub error_nolog_and_exit($@) {
    my $exit_code = shift;
    print::error_nolog(@_);
    exit($exit_code);
}
sub error_and_exit($@) {
    my $exit_code = shift;
    print::error(@_);
    exit($exit_code);
}

######
# Send a graphical notification to the user (using growl under Mac or
# notify-send under Linux)
# usage: notification(title, text [, priority])
##
sub notification($$@) {
    my $title    = shift;
    my $text     = shift;
    my $priority = shift;
    $priority    = defined($priority) ? $priority : 0;
    my $notify_cmd="";

    # Select notification system based on system
    if ($config::OS[0] =~ "Darwin") { # Mac OS X: use growlnotify
        $priority = max(min($priority, 2), -2);
        $notify_cmd =
          'growlnotify -p ' . $priority .
            ' -n '.$config::command.' -a \'iSync\' \'' . $title . '\' '.
              '-m \''. $text .'\' > /dev/null 2>&1';
    } elsif ($config::OS[0] =~ "Linux") {
        $priority = max(min($priority, 1), -1) +1;
        my @levels = ("low", "normal", "critical");
        $notify_cmd =
          'notify-send -u ' . $levels[$priority] .
            ' -i gtk-dialog-info \'' . $title . '\' \'' . $text . '\'';
    } else {
        print::warning('ibackup do not support graphical notification for the ',
                       $config::OS[0], " OS\n");
    }
    system::execute($notify_cmd);
}

######
# Ask the user is he wishes to continue.
##
sub really_continue() {
    print "Are you sure you want to continue? [yN] ";
    chomp(my $ans = <STDIN>);
    unless ($ans && ($ans =~ /y|yes|1/i)) {
        #sync::clean_after_sync();
        exit(0);
    }
}

####
# Print script version
##
sub version_msg() {
    print 'This is ', color('bold'), $config::command, color('reset'),
      ' version ', color('bold'), $config::VERSION, color('reset'), "\n",
        $config::PACKAGE_SUMMARY;

    print << 'EOF';
Copyright (c) 2009-2010 Sebastien Varrette (http://varrette.gforge.uni.lu)
with contributions by Guillaume-Jean Herbiet (http://herbiet.gforge.uni.lu)

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
}

#####
# print the content of a hash table
# Usage: print::hash_content(hash_ref [, title])
###
sub hash_content($@) {
    my $hash_ref = shift;
    my $title = defined ($_[0]) ? $_[0] : 'Hash Content';
    print::debug("============= $title =============\n");
    print::debug(Dumper $hash_ref);
}



##############################################################################
# PACKAGE FORMAT
# Handle all reformatting features
##############################################################################
package format;

use strict;
use warnings;
use Term::ANSIColor; # To send the ANSI color-change sequences to the user's terminal

#####
# return a colored message (coloration only appens in the terminal typically)
###
sub color_msg($@) {
    my $color = shift;
    return  Term::ANSIColor::color("$color") . "@_" . Term::ANSIColor::color("reset");
}

####
# interpret commands delimited by ` ` in a string.
# Return the string where `cmd` is replaced by the result of the command
# usage: interpret_cmd("string")
##
sub interpret_cmd($) {
    my $string = my $res = shift;
    my @commands = $string =~ /`([^`]+)`/g; # retrieve commands to interpret
    foreach my $cmd (@commands) {
        my $cmd_exec = `$cmd` || PRINT_ERROR_THEN_EXIT("Execute of $cmd failed or return and empty string: $!\n");
        chomp($cmd_exec);
        $cmd =~ s/\$/\\\$/g;    # Serialize command
        $cmd =~ s/\|/\\\|/g;    # idem
        $res =~ s/`$cmd`/$cmd_exec/;
    }
    return $res;
}

##############################################################################
# PACKAGE HASH
# Toolkit for managing perl hashes
##############################################################################
package hash;
use strict;
use warnings;

####
# check the existence of a set of keys in the hash table passed as reference
# return: 1 if every key listed exist in the hash, 0 otherwise
# Usage: hash::has_keys(hash_ref, key1 [,key2 ...])
##
sub has_keys($@) {
    my $hash_ref = shift;
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing keys') unless (@_);
    my $res = 1;
    foreach my $field (@_) {
        if (not exists($hash_ref->{$field})) {
            print::warning("The key $field do not exist");
            $res = 0;
        }
    }
    return $res;
}



##############################################################################
# PACKAGE LOG
# Handle all logging features
##############################################################################
package log;
use strict;
use warnings;

use Log::Handler;               # Log manager
#
# The following log levels are defined:
#     7   debug
#     6   info
#     5   notice
#     4   warning, warn
#     3   error, err
#     2   critical, crit
#     1   alert
#     0   emergency, emerg
#
# The message layout in the printf style with the following options:
#
#     %L   Log level
#     %T   Time or full timestamp (option timeformat)
#     %D   Date (option dateformat)
#     %P   PID
#     %H   Hostname
#     %U   User name
#     %G   Group name
#     %N   Newline
#     %S   Program name
#     %C   Caller - filename and line number
#     %p   Caller - package name
#     %f   Caller - file name
#     %l   Caller - line number
#     %s   Caller - subroutine name
#     %r   Runtime in seconds since program start
#     %t   Time measurement - replaced with the time since the last call of $log->$level
#     %m   Message
#     %%   Procent

our $handler    = Log::Handler->new();
our $timeformat = '%Y/%m/%d %H:%M:%S';
our $msg_layout = '%T [%L] %m';

########
# Initialize the log handler
# Usage: initialize([logdir],[email])
#        initialize([logdir])
#        initialize([email])
##
sub initialize(@) {
    my ($logdir, $email) = @_;

    # Recognize a mail address instead of a directory as
    if ((scalar(@_) == 1) &&
        ($logdir =~ /\b[\w0-9._%+-]+@(?:[\w0-9-]+\.)+[\w]{2,4}\b/)) {
        print "First argument is an email: $logdir\n";
        $email  = $logdir;
        $logdir = undef;
    }
    my $yellow_level  = format::color_msg('yellow',  '%L');
    my $magenta_level = format::color_msg('magenta', '%L');
    my $red_level     = format::color_msg('red',     '%L');

    my $debug_msg_layout = my $error_msg_layout = my $warning_msg_layout = $msg_layout;

    # ===  Initialize screen log (in the terminal) ===
    # Redirect debug logs to STDOUT (in yellow)
    $debug_msg_layout =~ s/%L/$yellow_level/g;
    $handler->add(
                  screen => {
                             log_to   => "STDOUT",
                             maxlevel => 7,
                             minlevel => 7,
                             timeformat      => "$timeformat",
                             message_layout  => "$debug_msg_layout",
                            }
                 );

    # Redirect common logs to STDOUT
    $handler->add(
                  screen => {
                             log_to   => "STDOUT",
                             maxlevel => 6,
                             minlevel => 5,
                             timeformat      => "$timeformat",
                             message_layout  => "$msg_layout",
                            }
                 );

    # redirect warnings to STDERR
    $warning_msg_layout =~ s/%L/$magenta_level/g;
    $handler->add(
                  screen => {
                             log_to   => "STDERR",
                             maxlevel => 4,
                             minlevel => 4,
                             timeformat      => "$timeformat",
                             message_layout  => "$warning_msg_layout",
                            }
                 );

    # Redirect errors to STDERR
    $error_msg_layout =~ s/%L/$red_level/g;
    $handler->add(
                  screen => {
                             log_to   => "STDERR",
                             maxlevel => 3, # error
                             minlevel => 0, # emerg
                             timeformat      => "$timeformat",
                             message_layout  => "$error_msg_layout",
                            }
                 );

    # ===  Initialize file log (in $logdir) ===
    if (defined($logdir)) {
        # ensure the directory exists
        print::error_and_exit(1,
                              "The directory $logdir do not exist: ",
                              "impossible to create log files into ",
                              "this directory\n")
            unless (-d "$logdir");

        # Initialie the log file for common logs
        $handler->add(
                      file => {
                               filename   => "${logdir}/common.log",
                               maxlevel   => 7, # debug
                               minlevel   => 5, # notice
                               timeformat      => "$timeformat",
                               message_layout  => "$msg_layout",
                              }
                     );

        # Initialize the log file for error logs
        $handler->add(
                      file => {
                               filename => "${logdir}/error.log",
                               maxlevel => 4, # warning
                               minlevel => 0, # emerg
                               timeformat      => "$timeformat",
                               message_layout  => "$msg_layout",
                              }
                     );
    }

    # Eventually mail errors/warnings
    if (defined($email)) {
        chomp(my $username = `whoami`);
        chomp(my $hostname = `hostname -f`);
        my $from = $username . '@' . $hostname;
        print::debug("Setup log by mail (from=$from) to $email\n");

        $handler->add(
                      sendmail => {
                                   from     => "${username}\@${hostname}",
                                   to       => "$email",
                                   subject  => "(ibackup)",
                                   maxlevel => 4,
                                   minlevel => 0,
                                   message_pattern => '%L',
                                   timeformat      => "$timeformat",
                                   message_layout  => "$msg_layout",
                                  }
                     );
    }
}

##############################################################################
# PACKAGE SYSTEM
# Handle all system calls/behaviour/information etc.
##############################################################################
package system;

use strict;
use warnings;
use Data::Dumper;

# List of mounted volume through the backup process, per mount type
our %MOUNTED_VOLUMES = (
                        'afp'          => undef,
                        'drive'        => undef,
                        'encfs'        => undef,
                        'sparsebundle' => undef,
                       );

####
# check the presence of the binaries @_ on the local system using 'which'
# usage:  check_binary(bin1 [, bin2 ...]);
##
sub check_binary(@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    my $which = "$ENV{'PATH'} which";
    foreach my $app (@_) {
        print::verbose("=> check availability of the command '$app' on the local system.");
        system::execute("which $app 1>/dev/null") &&
            print::error_and_exit(1, "$app: command not found in PATH=$ENV{'PATH'}");
    }
}

####
# check if the IP associated with an interface match another subnet.
# If no interface argument is provided, then
# usage: check_subnet(subnet [, interface])
##
sub check_subnet($@) {
    my $subnet = shift;
    my $IP = (@_) ? getIPFromInterface($_[0]) : getIPFromInterface();
    print::verbose("=> check subnet $subnet (current IP address found: $IP)");
    my $pattern=$subnet;
    $pattern =~ s/\./\\\./g;    # proceed with the '.' characters
    if ($IP !~ /$pattern/) {
        ibackup::Exception::Network->throw(error => "The IP adress $IP does not belong to the subnet $subnet");
    }
}

####
# check the existence of a set local directory
###
sub has_directory(@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing directory argument') unless (@_);
    foreach my $dir (@_) {
        unless ( -d $dir ) {
            ibackup::Exception::DirectoryNotFound->throw(error => "The directory $dir cannot be found")
          }
    }
}

#####
# execute a local command
# usage: execute(command)
###
sub execute(@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    print::debug('[' . (caller(0))[3] . "] @_\n");
    ($config::SIMULATION_MODE) ?
      print format::color_msg('bold', "@_\n") : system("@_");
    my $exit_status = $?;
    print::debug('[' . (caller(0))[3] . "] exit status : $exit_status\n");
    return $exit_status;
}

######
# get current IPs adresses using ifconfig.
# return an hash table associating an interface name with an IP and a state (up or down)
##
sub getIPs() {
    my $interface;
    my %IPs;
    foreach ( qx{ (LC_ALL=C /sbin/ifconfig -a 2>&1) } ) {
        $interface = $1 if /^(\S+?):?\s/;
        next unless defined $interface;
        $IPs{$interface}->{STATE}=uc($1) if /\b(up|down)\b/i;
        $IPs{$interface}->{IP}=$1 if /inet\D+(\d+\.\d+\.\d+\.\d+)/i;
    }
    return %IPs;
}

######
# get current IP adresses associated with an interface.
# If the interface parameter is not procided, the checked interfaces ar e (eth0,
# eth1) on Linux system and (en0, en1) on BSD-like.
# usage: getIPFromInterface(interface)
###
sub getIPFromInterface(@) {
    my %IPs = getIPs();
    print::debug("Analysing IPs on the local system. Found:\n");
    print::debug(Dumper \%IPs);
    my @interfaces;
    if (@_) {
        @interfaces = @_;
    } else {
        @interfaces = ('eth0', 'eth1') if ($config::OS[0] eq "Linux");
        @interfaces = ('en0',  'en1')  if ($config::OS[0] =~ "FreeBSD|OpenBSD|Darwin");
    }
    foreach my $i (@interfaces) {
        return $IPs{$i}->{IP} if ($IPs{$i} && $IPs{$i}->{IP});
    }
    # TODO: throw an exception here instead!
    print::error_and_exit(1,"IP not found for interface(s) @interfaces");
    return;
}

####
# Mount a local EncFS folder
# Usage: mount_encfs(rawdir, mountpoint [, password])
###
sub mount_encfs($$@) {
    my $rawdir     = shift;
    my $mountpoint = shift;
    print::verbose("=> prepare to mount the EncFS directory '$mountpoint'");

    # Ensure the encfs program is available
    system::check_binary('encfs');
    # Retrieve the password
    my $password   = (@_) ? shift : config::getPasswordForEntry("encfs://$mountpoint");

    print::debug("EncFS rawdir     : $rawdir");
    print::debug("EncFS mountpoint : $mountpoint");
    print::debug("EncFS mount passphrase : $password");

    # Analyze the EncFS raw directory
    unless ( -d "$rawdir" ) {
        print::warning("Unable to find the EncFS raw directory $rawdir");
        # throw an exception if run in quiet mode
        ibackup::Exception::DirectoryNotFound->throw(error => "EncFS raw directory not found")
            if ($config::QUIET);
        print::warning("=> about to create the directory $rawdir");
        print::really_continue();
        system::execute("mkdir -p $rawdir") && print::error_and_exit("Unable to create directory $rawdir");


        #execute("mkdir $mount_point") && PRINT_ERROR_THEN_EXIT("Unable to create directory $mount_point\n");
    }


    # Ensure you deal with a valid EncFS directory


}



#####
# execute a command on a remote server by ssh
# usage: ssh_remote_execute("user@host", port, "command")
###
sub remote_execute_by_ssh($$@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    my ($host, $port, @command) = @_;
    my $cmd = "ssh -p $port $host @command 1>/dev/null";
    return system::execute($cmd);
}


##############################################################################
# PACKAGE sync
# Handle all synchronization aspects etc.
##############################################################################
package sync;

use Hash::Util qw{lock_hash};   # To be able to lock keys/values in hash tables

# Store information on the synchronization command to be issued
our %BACKUP_CMD_INFO = (
                        'basecmd'     => 'rsync',
                        'opt'         => '',
                        'src'         => undef,
                        'dst'         => undef,
                        'dirs'        => undef,
                        'proto'       => undef,
                        'port'        => undef,
                        'target'      => undef,
                       );
our %DEFAULT_BACKUP_CMD_INFO = %BACKUP_CMD_INFO;
lock_hash(%DEFAULT_BACKUP_CMD_INFO); # for extra safety

###
# setup the target of the backup command to an external drive or a local directory
# usage: set_backup_target_to_drive(path)
##
sub set_backup_target_to_drive($) {
    my $path = shift;
    $BACKUP_CMD_INFO{'dst'} = format::interpret_cmd($path);
    # Ensure the target drive starts with a '/'
    if ($BACKUP_CMD_INFO{'dst'} !~ /^\//) {
        print::warning("The target drive path ($BACKUP_CMD_INFO{'dst'})",
                       "does not starts with a '/' => '/' character added\n");
        $BACKUP_CMD_INFO{'dst'} = "/$BACKUP_CMD_INFO{'dst'}";
    }
    # Now ensure the target directory exists
    unless ( -d "$BACKUP_CMD_INFO{'dst'}") {
        ibackup::Exception::DirectoryNotFound->throw(error => "The target $BACKUP_CMD_INFO{'dst'} cannot be found");
    }
    # Add the drive to the list of mounted volumes
    push(@{$system::MOUNTED_VOLUMES{ $BACKUP_CMD_INFO{'proto'} }}, $BACKUP_CMD_INFO{'dst'})
      unless ($BACKUP_CMD_INFO{'proto'} eq 'file');
    if (defined $config::SETTINGS{'encfs_rawdir'}) {
        system::mount_encfs($config::SETTINGS{'encfs_rawdir'}, $path)
    }
}


###
# setup the target of the backup command to a remote server reachable by SSH
# usage: set_backup_target_to_ssh_server(user, server, port)
##
sub set_backup_target_to_ssh_server($$$) {
    my ($user, $server, $port) = @_;
    $BACKUP_CMD_INFO{'port'}   = $port;
    $BACKUP_CMD_INFO{'target'} = "$user" . '@' . "$server";
    if ($BACKUP_CMD_INFO{'basecmd'} eq 'rsync') {
	$BACKUP_CMD_INFO{'opt'} .= "--rsh=" . (($port == 22) ? "ssh" : "'ssh -p $port'");
	$BACKUP_CMD_INFO{'dst'} = "$user" . '@' . "$server:";
    } else {
        ibackup::Exception::ConfigFileFormat->throw(error => "The use of duplicity is not yet supported");
    }
}


####
# Configure the synchronization command to be executed (This assumes the hash
# $config::SETTINGS is correctly populated)
# This function may throw the following exceptions:
##
sub set_cmd() {
    if ($config::SETTINGS{'use_duplicity'} =~ /1|y|yes/i) {
        ibackup::Exception::ConfigFileFormat->throw(error => "The use of duplicity is not yet supported");
    }
    # Set the backup source i.e the root directory of the local folders to
    # backup, ensuring this directory exists
    my $src_rootdir = format::interpret_cmd($config::SETTINGS{'src_rootdir'});
    system::has_directory( $src_rootdir );
    $BACKUP_CMD_INFO{'src'} = $src_rootdir;

    # Set the backup destination by analysing the target_url
    sync::parse_target_url();

}


####
# Analyse the target url (stored in $config::SETTINGS{'target_url'} normally)
# that specify the backup destination.
##
sub parse_target_url() {
    unless (defined($config::SETTINGS{'target_url'})) {
        ibackup::Exception::ConfigFileFormat->throw(error => "Undefined target_url for this profile");
    }
    $config::SETTINGS{'target_url'} = format::interpret_cmd("$config::SETTINGS{'target_url'}");
    # let the Perl magic operate here:
    $config::SETTINGS{'target_url'} =~ /^\b(\w+):\/\/(([\.\w\/]+)(:([\w]+))?((\@([-\w\.]+))(:(\d+))?)?(\/([\.\w\/]+))?)/;
    my ($proto, $target, $user, $passwd, $server, $port, $volname) = ($1, $2, $3, $5, $8, $10, $12);
    print::debug("Protocol: $proto\n")   if ($proto);
    print::debug("target  : $target\n")  if ($target);
    print::debug("user    : $user\n")    if ($user);
    print::debug("passwd  : $passwd\n")  if ($passwd);
    print::debug("server  : $server\n")  if ($server);
    print::debug("port    : $port\n")    if ($port);
    print::debug("volname : $volname\n") if ($volname);

    unless ($proto && $target) {
        ibackup::Exception::ConfigFileFormat->throw(error => "Malformed target url $config::SETTINGS{'target_url'}");
    }
    $BACKUP_CMD_INFO{'proto'}  = $proto;
    $BACKUP_CMD_INFO{'target'} = $target;

    my $set_to_msg="=> set the backup destination to";

    # Handle each protocol
    if ($proto eq 'drive') {
        print::verbose("$set_to_msg the external drive $target\n");
        set_backup_target_to_drive($target);
    } elsif ($proto eq 'file') {
        print::verbose("$set_to_msg the local directory $target\n");
        set_backup_target_to_drive($target);
    } elsif ($proto eq 'ssh') {
        unless ($user && $server) {
            ibackup::Exception::ConfigFileFormat->throw(error => "Configuration file format error: Malformed ssh target $target");
        }
        $port = 22 unless ($port);
        print::verbose("$set_to_msg the remote server $server");
        print::verbose("\t SSH connexion to be established (user: $user - port: $port)");
        set_backup_target_to_ssh_server($user, $server, $port);
    }

    #         # Remote server reacheable by ssh
    #         case 'ssh'
    #           {
    #            PRINT_ERROR_THEN_EXIT("Malformed ssh target") unless ($user && $server);
    #            $port = 22 unless ($port);
    #            verbose("\tsetup target on the remote server $server.\n");
    #            verbose("\tConnection to be established for the remote user $user by ssh on port $port\n");
    #            setup_target_ssh($user, $server, $port);
    #           }
    #             # sparsebundle
    #             case 'sparsebundle'
    #               {
    #                PRINT_ERROR_THEN_EXIT("Sparsebundle images are only supported under Mac OS X") unless ($OS[0] =~ "Darwin");
    #                verbose("\tsetup target on the sparsebundle image $target\n");
    #                setup_target_sparsebundle($target);
    #               }
    #                 case 'afp'
    #                   {
    #                    PRINT_ERROR_THEN_EXIT("Apple Filing Protocol (AFP) are only supported under Mac OS X") unless ($OS[0] =~ "Darwin");
    #                    $port = 548 unless ($port);
    #                    verbose("\tsetup target on the remote server $server.\n");
    #                    verbose("\tConnection to be established for the remote user $user by afp\n");
    #                    setup_target_afp($user, $passwd, $server, $port, $volname);
    #                   }
    #                     # ERROR: NOT supported => raise error
    #                     else {
    #                         PRINT_ERROR_THEN_EXIT("The protocol $proto is not supported");
    #                     }
    # }



}


##############################################################################
# PACKAGE config
# Handle all configuration aspects etc.
##############################################################################
package config;

use strict;
use warnings;

use Storable qw(dclone);        # for recursive copy of nested hash
use Hash::Util qw{lock_hash};   # To be able to lock keys/values in hash tables
use Getopt::Long;
use Data::Dumper;

# Generic variables
our $VERSION = '@VERSION@';                 # Script version
our $PACKAGE_SUMMARY = '@PACKAGE_SUMMARY@'; # Package summary
our $PACKAGE_WEBSITE = '@PACKAGE_WEBSITE@'; # Package website
our $VERBOSE = 1;            # option variable for verbose mode (default: false)
our $DEBUG   = 1;            # option variable for debug mode with default
# value (false)
our $QUIET   = 0;               # By default, display all informations
our $numargs = scalar(@ARGV);   # Number of arguments
our $command = `basename $0`;   # base command
chomp($command);

# Specific variables
our $SIMULATION_MODE = 0;       # By default, don't simulate
our $SYNC_MODE = "--update"; # By default, update directories, don't delete obsolete files
our $HISTORICAL      = 0;   # By default do not keep an history of older backups
our $MAC_FORK        = 0; # option variable for Mac OS resource forks with default value (false)
our $NOTIFICATION    = 0; # By default, don't use system user notification feature
our $RETRIEVE_MODE   = 0; # By default, push data on the backup target and don't retrieve anything
our $PRE_SCRIPT;          # Complete path to pre-backup script
our $POST_SCRIPT;         # Complete path to post-backup script

our $file;                # Configuration file.
our @backup_sections;     # backup sections to be used in the configuration file
our @OS = qx(uname);      # Current OS

# Configuration settings as extracted/expanded from the configuration file
our %SETTINGS = (
                 'use_duplicity'         => 'no',
                 'log_file'              => undef, # TODO: NOW log dir
                 'password_file'         => undef,
                 'patternfile_exclude'   => undef,
                 'restrict_on_subnet'    => undef,
                 'src_rootdir'           => '/',
                 'dst_rootdir'           => '/',
                 'include_dir'           => undef,
                 'exclude_dir'           => undef,
                 'exclude_dir_exception' => undef,
                 'Directory'             => undef,
                 'target_url'            => undef,
                 'logdir'                => undef,
                 'email'                 => undef,
                 'encfs_rawdir'          => undef,
                );
our %DEFAULT_SETTINGS = %SETTINGS;
lock_hash(%DEFAULT_SETTINGS);   # for extra safety

our %GETOPT_CONFIG = (
                      # Specific options
                      's|section=s'     => \@backup_sections, # sections to consider
                      'f|config-file=s' => \$file, # Configuration file
                      'n|dry-run'       => \$SIMULATION_MODE, # Simulation mode
                      'm|mac-fork'      => \$MAC_FORK, # Mac resource fork
                      'notification'    => \$NOTIFICATION, # User notification features
                      'e|exact-sync|delete' => sub { $SYNC_MODE="--delete" }, # Exact synchro
                      'history'         => sub { # Keep history of backups
                          $HISTORICAL = 1;
                          $SYNC_MODE="--delete"
                      },
                      'p|push'          => sub { $RETRIEVE_MODE = 0}, # push data on the backup target
                      'r|restore|retrieve' => sub { $RETRIEVE_MODE = 1}, # restore data from the backup
                      'pre-script=s'    => \$PRE_SCRIPT, # script to be executed before the sync
                      'post-script=s'   => \$POST_SCRIPT, # script to be executed afetr the sync
                      # Generic (classical) options
                      'v|verbose'  => \$VERBOSE, # Verbose mode
                      'q|quiet'    => \$QUIET,   # Quiet mode
                      'debug'      => sub { $DEBUG = 1; $VERBOSE = 1; }, # Debug mode
                      'h|help'     => sub { ::pod2usage(-exitval => 1, # Show help
                                                        -verbose => 2); },
                      'version'    => sub { print::version_msg(); exit(0); } # Show version
                     );

our %CONFIG_FILE_CONTENT;      # Hash table constructed from the analysis of the
                               # content of the configuration file via
                               # Config::General

####
# reset the settings
##
sub reset_settings() {
    %config::SETTINGS      = %config::DEFAULT_SETTINGS;
    %sync::BACKUP_CMD_INFO = %sync::DEFAULT_BACKUP_CMD_INFO;
}

####
# Update the backup settings i.e. the hash $SETTINGS from the informations
# stored in $CONFIG_FILE_CONTENT{profile} i.e. a given profile (or section) in
# the configuration file.
# Usage: update_settings_from("profile")
##
sub set_profile($) {
    my $profile = shift;
    print::verbose("set the '$profile' profile");
    my %subsection = %{ dclone($CONFIG_FILE_CONTENT{$profile})}; # deep copy
    while (my ($key, $val) = each(%subsection)) {
        # Special treatment for the SSH agent
        if ($key eq 'ssh_auth_sock') {
            $ENV{SSH_AUTH_SOCK} = format::interpret_cmd($subsection{'ssh_auth_sock'});
            print::debug('Setting the environment variable SSH_AUTH_SOCK ',
                         "to $ENV{SSH_AUTH_SOCK}");
            next;
        }
        if (($key eq 'Directory') && defined($SETTINGS{$key})) {
            # Here we need to append the directories definitions
            while ( my ($dir, $dir_setting) = each(%{$subsection{$key}})) {
                $SETTINGS{$key}->{$dir} = $dir_setting;
            }
            next;
        }
        if (exists($SETTINGS{$key})) {
            $SETTINGS{$key} = $val;
        } else {
            print::error_and_exit(1, "The directive $key is not recognized");
        }
    }
}

####
# ensure the existence of the directives listed in arguments in the merged
# configuration of a given backup profile i.e. in $config::SETTINGS. Throw an
# exception of type ibackup::Exception::ConfigFileFormat in case of error.
##
sub ensure_profile_set(@) {
    print::error_and_exit(1, '[' . (caller(0))[3] . '] missing argument') unless (@_);
    foreach my $directive (@_) {
        unless (exists($config::SETTINGS{$directive})) {
            my $error_msg =
              "The directive '" .
                format::color_msg('bold', "$directive") .
                    "' is not set in the configuration file";
            ibackup::Exception::ConfigFileFormat->throw(error => "$error_msg");
        }
    }
}

####
# Retrieve password entry from file formatted as follows: 
#       entry_name1    password1
#       entry_name2    password2
#       .....
#
# usage: config::getPasswordFromFile(password_file, entry)
##
sub getPasswordFromFile($$) {
    my $file = shift;
    my $entry = shift;
    my $password = "";
    my $found = 0;
    open(FILE, "$file") || die("Cannot open $file: $!\n");
    while (<FILE>) {
	chomp;
	next unless (/\s*$entry\s+(.*)/);
	$password = $1;
	print::debug("Found password for the entry '$entry' in file $file");
	$found = 14; #psh psh
        last;
    }
    close FILE;
    ibackup::Exception::ConfigFileFormat->throw(error => "Could not retrieve the password for the entry '$entry' in the password file '$file'") unless ($found);
    return $password;
}

####
# As above, using the password_file $config::SETTINGS{'password_file'}
# usage: config::getPasswordForEntry(entry)
##
sub getPasswordForEntry($) {
    my $entry = shift;
    ibackup::Exception::ConfigFileFormat->throw(error => "No password file defined in $config::file (you should set the 'password_file' directive)")
        unless (defined $config::SETTINGS{'password_file'});
    my $password_file  = $config::SETTINGS{'password_file'};
    ibackup::Exception::ConfigFileFormat->throw(error => "Password file $password_file not found!") 
        unless ( -f "$password_file" );
    return getPasswordFromFile($password_file, $entry);
}



##############################################################################
# PACKAGE EXCEPTION
# Define the exceptions throwed by ibackup
##############################################################################
package ibackup::Exception;

use Exception::Class (
                      # Main exception class
                      'ibackup::Exception' =>
                      {
                       description => 'Generic base class for all exception of this script'
                      },
                      # Specific exceptions
                      'ibackup::Exception::Network' =>
                      {
                       isa         => 'ibackup::Exception',
                       description => 'Exception related to network errors (bad subnet etc.)',
                       alias       => 'network_error',
                      },
                      'ibackup::Exception::ConfigFileFormat' =>
                      {
                       isa         => 'ibackup::Exception',
                       description => 'Error in the formatting of the configuration file',
                      },
                      'ibackup::Exception::DirectoryNotFound' =>
                      {
                       isa         => 'ibackup::Exception',
                       description => 'A directory used in the backup do not exist',
                      },
                     );


##############################################################################
#     PACKAGE MAIN
##############################################################################
package main;

use strict;
use warnings;

use Exception::Class::TryCatch;
use Hash::Util qw{lock_hash};   # To be able to lock keys/values in hash tables
use Config::General;            # For configuration file parsing
use Getopt::Long;               # For command line management (long version)
use Pod::Usage;
use Data::Dumper;
use Term::ANSIColor;

# PATH (/sbin required for mount_afp)
$ENV{'PATH'} = "$ENV{'PATH'}:/bin:/usr/bin:/usr/local/bin:$ENV{'HOME'}/bin:/sbin";

# Initialize the logs
log::initialize();

# Process command line
my $getoptRes = GetOptions(%config::GETOPT_CONFIG);
print::error_and_exit(1, "Please check the format of the command-line. ",
                      "Use '$config::command --help' for more details") unless ($getoptRes);

# Ensure the notification command exists (if used)
if ($config::NOTIFICATION) {
    system::check_binary('growlnotify') if ($config::OS[0] =~ "Darwin"); # Mac OS X: check growlnotify
    system::check_binary('notify-send') if ($config::OS[0] =~ "Linux"); # Linux: check notify-send
}

# Disable quiet mode on retrieval of data
if ($config::QUIET && $config::RETRIEVE_MODE) {
    $config::QUIET = 0;
    print::info("Quiet mode desactivated when retrieving data\n");
}

if (($config::SYNC_MODE eq "--delete") && (! $config::QUIET)) {
    print::warning("This option force an exact duplication and can lead to deletion of files.\n");
    print::really_continue();
}

# Allow comma-separated backup_sections:
#  --sections=toto,tutu is equivalent to --sections=toto --sections=tutu
@config::backup_sections = split(/,/,join(',',@config::backup_sections));
@config::backup_sections = ('default') unless (@config::backup_sections);

# Find the relevant configuration file
unless ($config::file) {
    my @conffile_list = ('/etc/backup.conf', "$ENV{HOME}/.backup.conf");
    # if no configuration file found in the command-line arguments, check
    # successively for files listed in @conffile_list
    foreach my $f (@conffile_list) {
        $config::file = $f if (-e $f);
    }
    print::error_and_exit(1, "No configuration file found among @conffile_list")
        unless ($config::file);
}
print::verbose("=> configuration file : $config::file");

# Now put the content of the configuration file into an hash table
%config::CONFIG_FILE_CONTENT = Config::General::ParseConfig(-ConfigFile => $config::file,
                                                            -InterPolateEnv => 1);
print::error_and_exit(1,
                      "Empty backup configuration:",
                      "ensure that the content of $config::file is correct!")
  unless (%config::CONFIG_FILE_CONTENT);

lock_hash(%config::CONFIG_FILE_CONTENT);
print::debug("Creation of the hash table from the configuration file $config::file : ");
print::debug(Dumper \%config::CONFIG_FILE_CONTENT);

print::debug("Backup section(s) to consider in the configuration file :",
             color('bold'), @config::backup_sections, color('reset'));

# Check the configuration file format : there should be a section 'global' and
# one for each backup profile considered
unless (hash::has_keys(\%config::CONFIG_FILE_CONTENT,
                       'global', @config::backup_sections)) {
    print::error_and_exit("Missing profile section in $config::file");
}
# TODO: execute pre-script if available

# ============================================================================
# ========== Now proceed with each section (i.e. each backup profile) ========
# ============================================================================
foreach my $sec (@config::backup_sections) {
    print::info('---------- ', color('bold'), "$sec ", color('reset'),
                ' backup profile ----------');
    # Restore global settings
    config::reset_settings();

    # Now merge the global profile and the selected one
    config::set_profile('global');
    config::set_profile("$sec");
    print::hash_content(\%config::SETTINGS, 'backup settings configured');

    #try
    eval {
        config::ensure_profile_set('src_rootdir', 'dst_rootdir',
                                   'include_dir', 'target_url');
        sync::set_cmd();

    };
    # catch
    if ( catch my $err ) {
        if ($err->isa('ibackup::Exception::Network')          ||
            $err->isa('ibackup::Exception::ConfigFileFormat') ||
            $err->isa('ibackup::Exception::DirectoryNotFound')) {
            print::error($err->error);
        } else {
            # not recoverable
            print::warn "Unrecoverable error: $err \n";
            $err->rethrow;
        }
        print::warn("The profile $sec is now ",
                    format::color_msg('bold', 'skipped'), " !");
        print "\n";
        next;
    }


}

# TODO: execute post-script if available







#print::debug("IP found: ", system::getIPFromInterface());

# #try
# eval {
#     system::check_subnet('193.168');
# };
# # catch
# if ( catch my $err ) {
#     if ($err->isa('ibackup::Exception::Network')) {
#         print::warn("Network exception: ", $err->error);
#     } else {
#         # not recoverable
#         print::warn "Unrecoverable error: $err\n";
#         $err->rethrow;
#     }
# }



# print::debug("debug");
# print::info("info");
# print::verbose("verbose");
# print::warn("Warning");
# print::error("error");

#print::notification('Title', "msg");



#################### Initial POD documentation ######################
=pod

=head1 NAME

I<backup>, @PACKAGE_SUMMARY@

I<backup> relies for that on B<rsync> (see L<http://samba.anu.edu.au/rsync/>) and
(in a future release) B<duplicity> (see L<http://duplicity.nongnu.org/>) together with a
configuration file.

=head1 SYNOPSIS

      backup [options]

=head1 DESCRIPTION

I<backup> rely on a configuration file to describe the characteristics of the
backup job to be performed (files to include/exclude, target url etc. -- see
L<CONFIGURATION FILE FORMAT> for more details).
The main idea is to have the possibility to define several backup profile.
Here is a illustrative examples:

    # Configuration file example
    #
    #### Mandatory global settings ####
    <global>
         src_rootdir = $HOME     # Root directory on the (local) source
         include_dir = *         # backup all sub-directories (relative to src_rootdir)
    </global>

    #### Mandatory default backup definition ####
    <default>
         target_url = drive:///Volumes/Backup  # backup on an external drive 'Backup'
    </default>

    # Definition of the backup on a local [encrypted] sparse bundle (Mac OS X)
    <sbimage>
         target_url  = sparsebundle:///path/to/image.sparsebundle
         dst_rootdir = myBackup         # Specialized root directory for this backup
    </sbimage>

    # Definition of the backup on the machine 'toto' (via SSH access)
    <toto>
         target_url  = ssh://mylogin@toto.example.org  # backup through ssh
         dst_rootdir = /backup/`whoami`@`hostname`     # Specialized root directory on target server
         restrict_on_subnet = 10.7.14                  # backup only when you're working
    </toto>

    # Definition of the backup on the company NAS (via AFP access)
    <nas>
          # backup through AFP (eventually put the password in a separate file and use the directive 'password_file')
  target_url  = afp://mylogin:mypassword@nas.company.com/volname
  dst_rootdir = myBackup               # Root directory for the backup
  restrict_on_subnet = 10.7.14         # backup only when you're working
  </nas>

  # Definition of the backup on a remote [encrypted] sparse bundle on the company NAS
  <nassbimage>
  target_url  = afp://mylogin:mypassword@nas.company.com/volname/path/to/image.sparsebundle
  dst_rootdir = myBackup               # Root directory for the backup
  restrict_on_subnet = 10.7.14         # backup only when you're working
  </nassbimage>

  So appart from the 'global' section, each backup is defined in a named block that helps
  to complete and/or overwrite the global settings.
To run the backup configured by default, just run:

    ./backup -f /path/to/config_file

  To run the backup configured by the 'toto' section, just run:

./backup -f /path/to/config_file -s=toto

  If a configuration file is not passed command-line through the C<-f> option, I<backup>
  use by default $HOME/.backup.conf and then /etc/backup.conf.

  To restore data from the backup 'toto', run :

  ./backup -f /path/to/config_file -s=toto -r

  Note that I<backup> try to use the configuration files C</etc/backup.conf> or C<~/.backup.conf>
  so that the C<-f> option can be avoided.

  =head1 OPTIONS

  The following options are available:



=cut


  # POD documentation to be done:
  #Suggested by Damian Conway in Perl Best Practices.
  #Name
  #Usage
  #Description
  #Required arguments
  #Options
  #Exit status
  #Diagnostics
  #Configuration
  #Dependencies
  #Incompatibilities
  #Bugs and limitations
  #Author
  #License and copyright
  #Disclaimer of warranty
