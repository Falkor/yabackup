#!/usr/bin/perl  -w
#########!@PERL@ -w

##############################################################################
# File   : backup
# Authors: Sebastien VARRETTE	  <Sebastien.Varrette@uni.lu>
#          Guillaume-Jean HERBIET <Guillaume.Herbiet@uni.lu>
# $Id$
#
# Description : @PACKAGE_SUMMARY@
#               See the man page for more information.
#
# Copyright (c) 2009 Sebastien Varrette     (http://varrette.gforge.uni.lu/)
#                    Guillaume-Jean Herbiet (http://herbiet.gforge.uni.lu/)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Sebastien Varrette                               \n
# <Sebastien.Varrette@uni.lu>                      \n
# Guillaume-Jean Herbiet                           \n
# <Guillaume.Herbiet@uni.lu>                       \n
# University of Luxembourg                         \n
# 6, rue Richard Coudenhove-Kalergi                \n
# L-1359 Luxembourg                                \n
##############################################################################
use strict;
use warnings;

# Used packages
use Switch;
use Storable qw(dclone);      # for recursive copy of nested hash 
use Hash::Util qw{lock_hash}; # To be able to lock keys/values in hash tables
use List::Util qw[min max];   # To find min/max values
use POSIX qw(strftime);       # To format time 
use Getopt::Long;             # For command line management (long version)
use Config::General;          # For configuration file parsing
use Term::ANSIColor;          # To send the ANSI color-change sequences to the 
                              #    user's terminal
# TODO: add a sort of #ifdef __DARWIN__ here for Data::Plist not required on other systems
use Mac::PropertyList qw(parse_plist);       # To parse plist files obtained under Mac OS X 

use Data::Dumper;
use Pod::Usage;

# PATH
$ENV{'PATH'} = "$ENV{'PATH'}:/bin:/usr/bin:/usr/local/bin:$ENV{'HOME'}/bin";

# Generic variables
my $VERSION = '@VERSION@';    # Script version
my $VERBOSE = 0;              # option variable for verbose mode with default value (false)
my $DEBUG   = 0;              # option variable for debug mode with default value (false)
my $QUIET   = 0;              # By default, display all informations
my $numargs = scalar(@ARGV);  # Number of arguments
my $command = `basename $0`;  # base command
chomp($command);

# Specific variables
my $SIMULATION_MODE = 0;          # By default, don't simulate
my $SYNC_MODE       = "--update"; # By default, update directories, don't delete obsolete files
my $HISTORICAL      = 0;          # By default do not keep an history of older backups
my $MAC_FORK        = 0;          # option variable for Mac OS resource forks with default value (false)
my $NOTIFICATION    = 0;          # By defautlt, don't use system user notification feature
my $RETRIEVE_MODE   = 0;          # By default, push data on the backup target and don't retrieve anything
my $PRE_SCRIPT;                   # Complete path to pre-backup script
my $POST_SCRIPT;                  # Complete path to post-backup script

my $config_file;                  # Configuration file.
my @backup_sections;              # backup sections to be used in the configuration file 
my @OS = qx(uname);               # Current OS

# configuration file sections
my %SETTINGS = (
		'use_duplicity'         => 'no', 
		'log_file'              => undef,
		'patternfile_exclude'   => undef,
		'restrict_on_subnet'    => undef,
		'src_rootdir'           => '/',
		'dst_rootdir'           => '/',
		'include_dir'           => undef,
		'exclude_dir'           => undef,
		'exclude_dir_exception' => undef,
		'Directory'             => undef,
		'target_url'            => undef,
	       );

# Element of the backup command (populated while parsing the configuration file) 
my %BACKUP_CMD_INFO = (
		       'basecmd'     => 'rsync',
		       'opt'         => '',
		       'src'         => undef,
		       'dst'         => undef,
		       'dirs'        => undef,
		       'proto'       => undef,
		       'port'        => undef,
		       'target'      => undef,
		      );

# Hash of drives mounted by the script (to be unmounted at the end)
my %MOUNTED_VOLUMES = (
		       'afp'          => undef,
		       'drive'        => undef,
		       'sparsebundle' => undef,
		       );

my %DEFAULT_SETTINGS        = %SETTINGS;
my %DEFAULT_BACKUP_CMD_INFO = %BACKUP_CMD_INFO;
lock_hash(%DEFAULT_SETTINGS);        # for extra safety
lock_hash(%DEFAULT_BACKUP_CMD_INFO); # for extra safety

# Process command line
my $getoptRes = GetOptions(# Specific options
			   'section=s'       => \@backup_sections,              # sections to consider
			   'config-file|f=s' => \$config_file,                  # Configuration file
			   'dry-run|n'       => \$SIMULATION_MODE,              # Simulation mode
			   'mac-fork|m'      => \$MAC_FORK,                     # Mac resource fork
			   'notification'    => \$NOTIFICATION,                 # User notification features
			   'exact-sync|e'    => sub { $SYNC_MODE="--delete" },  # Exact synchro
			   'history'         => sub {                           # Keep history of backups
				      $HISTORICAL = 1;
				      $SYNC_MODE="--delete"
				},
			   'push|p'          => sub { $RETRIEVE_MODE = 0},      # push data on the backup target
			   'restore|retrieve|r' => sub { $RETRIEVE_MODE = 1},   # restore data from the backup
			   'pre-script=s'      => \$PRE_SCRIPT,
			   'post-script=s'     => \$POST_SCRIPT,
			   # Generic (classical) options
			   'verbose|v'  => \$VERBOSE,                           # Verbose mode
			   'quiet|q'    => \$QUIET,                             # Quiet mode
			   'debug'      => sub { $DEBUG = 1; $VERBOSE = 1; },   # Debug mode
			   'help|h'     => sub { pod2usage(-exitval => 1,
							  -verbose => 2); },    # Show help
			   'version'    => sub { VERSION_MESSAGE(); exit(0); }  # Show version
			  );

PRINT_ERROR_THEN_EXIT("check the format of the command-line") unless ($getoptRes);
if ($NOTIFICATION) {
    check_binary('growlnotify') if ($OS[0] =~ "Darwin"); # Mac OS X: check growlnotify
    check_binary('notify-send') if ($OS[0] =~ "Linux");  # Linux: check notify-send
}

if ($QUIET && $RETRIEVE_MODE) {
    $QUIET = 0;
    info("Quiet mode desactivated when retrieving data\n");
}
if (($SYNC_MODE eq "--delete") && (! $QUIET)) { 
    warning("This option force an exact duplication and can lead to deletion of files.\n");
    really_continue();
}

# Process configuration file
unless ($config_file) {
    my @conffile_list = ('/etc/backup.conf', "$ENV{HOME}/.backup.conf");
    # if no configuration file found in the command-line arguments, check successively for files listed 
    # in @conffile_list
    foreach my $f  (@conffile_list) {
	$config_file = $f if (-e $f);
    }
    PRINT_ERROR_THEN_EXIT("No configuration file found among @conffile_list") unless ($config_file);
}
verbose("=> Configuration file : $config_file\n");
my %CONFIGS = Config::General::ParseConfig(-ConfigFile => $config_file, 
					   -InterPolateEnv => 1);

PRINT_ERROR_THEN_EXIT("Empty configuration") unless (%CONFIGS);


lock_hash(%CONFIGS);
debug("Creation of the hash table from the configuration file $config_file : \n");
debug(Dumper \%CONFIGS); 

# I allow comma-separated backup_sections: --sections=toto,tutu is equivalent to --sections=toto --sections=tutu
@backup_sections = split(/,/,join(',',@backup_sections));
@backup_sections = ('default') unless (@backup_sections);
debug("Backup section(s) to consider in the configuration file : @backup_sections\n");
# Check configuration file format : you should have a section 'global' + one for each backup config asked
ensure_section_exists('global', @backup_sections);

# proceed with each section 
foreach my $sec (@backup_sections) {
    info('Proceeding backup configured in section ' . color('bold') . "$sec" . color('reset') . "\n");
	
    # run pre-backup script if specified
    info("Executing pre-backup script.\n") if defined $PRE_SCRIPT;
    external_script_execute($PRE_SCRIPT, "pre") if defined $PRE_SCRIPT;
    
    # get the settings for this synchro
    debug("Add global settings\n");
    restore_global_settings();
    debug("Append specific settings from section $sec\n");
    update_settings_from($CONFIGS{$sec});
    print_current_settings();
    ensure_defined_settings('src_rootdir', 'dst_rootdir', 'include_dir', 'target_url');
    
    # configure the command to be executed
    configure_sync_cmd();
    
    # run the command
    run_sync_cmd();

    # clean after the syncho (umount sparsebundle/afp volumes etc.)
    clean_after_sync();

    # run post-backup script if specified
    info("Executing post-backup script.\n") if defined $POST_SCRIPT;
    external_script_execute($POST_SCRIPT, "post") if defined $POST_SCRIPT;
}


#################################################################################
############## ------------------ Sub routines  ------------------ ##############
#################################################################################

######
# Print information in the following form: '[$2] $1' ($2='=>' if not submitted)
# usage: info(text [,title])
##
sub info {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    my $prefix = $_[1] ? $_[1] : '=>';
    print "$prefix $_[0]" unless $QUIET;
}

######
# Print verbose information (i.e print only if $VERBOSE is set)
# usage: verbose(text)
##
sub verbose {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    print @_ if ${VERBOSE};
}

######
# Print debug information (i.e print only if $DEBUG is set)
# usage: debug(text)
##
sub debug {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    info(@_, '['. color("yellow") . 'DEBUG' . color("reset") . ']') if ${DEBUG};
}

######
# Print error message 
# usage: error(text)
##
sub error {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    info(@_, '['. color("red") . 'ERROR' . color("reset") . ']');
}

######
# Print warning message 
# usage: warning(text)
##
sub warning {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    info(@_, '['. color("magenta") . 'WARNING' . color("reset") . ']');
}

######
# Send a graphical notification to the user
# usage: notification(title, text, $priority)
##
sub notification {
	my $title    = shift;
	my $text     = shift;
	my $priority = shift;
	$priority = defined($priority)?$priority:0;
	
	# Select notification system based on system
	if ($OS[0] =~ "Darwin") {   	# Mac OS X: use growlnotify
		$priority = max(min($priority, 2), -2);
		execute('growlnotify -p '.$priority.' -n '.$command.' -a \'Time Machine\' \''.$title.'\' -m \''.$text.'\' > /dev/null 2>&1');
	}
	elsif ($OS[0] =~ "Linux") {
		$priority = max(min($priority, 1), -1) +1;
		my @levels = ("low", "normal", "critical"); 
		execute('notify-send -u '.$levels[$priority].' -i gtk-dialog-info \''.$title.'\' \''.$text.'\'');
		#PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] Notification is only supported under Mac OS X so far.');
	}
}

######
# Ask the user is he/she wish to continue. 
##
sub really_continue {
    print "Are you sure you want to continue? [yN] ";
    chomp(my $ans = <STDIN>);
    unless ($ans && ($ans =~ /y|yes|1/i)) {
	clean_after_sync();
	exit(0);
    }
}

####
# print the settings hash table
##
sub print_current_settings {
    debug("============= Current settings =============\n");
    debug(Dumper \%SETTINGS);
}

sub print_current_cmd_info {
    debug("============= Current backup cmd info =============\n");
    debug(Dumper \%BACKUP_CMD_INFO);
}
####
# Print error message then exit with error status
# Optionnal parameter $_[0] : error message ('Bad format' by defaut) 
##
sub PRINT_ERROR_THEN_EXIT {
    my $msg = $_[0] ? $_[0] : 'Bad format';
    error "$msg\n";
    append_to_log("[ERROR] $msg");
    notification("Backup aborted due to error", $msg, 1) if ($NOTIFICATION);
    exit(1);
}

#####
# execute a local command 
# usage: execute(command)
###
sub execute {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing command argument') unless (@_);
    debug('[' . (caller(0))[3] . "] @_\n");
    $SIMULATION_MODE ? 
      print '(', color('bold'), 'simulation', color('reset'), ") @_\n" : system("@_");  
    my $exit_status = $?;
    debug('[' . (caller(0))[3] . "] exit status : $exit_status\n");
    return $exit_status;
}

#####
# execute a command on a remote server by ssh 
# usage: ssh_remote_execute("user@host", port, "command")
###
sub ssh_remote_execute {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] malformed arguments') unless (scalar(@_) >= 3);
    my ($host, $port, @command) = @_;
    my $cmd = "ssh -p $port $host @command 1>/dev/null";
    return execute($cmd);
}

#####
# execute an external script beofre (pre) or after (post) the backup
# usage: external_script_execute("/path/to/script", "pre|post")
###
sub external_script_execute {
	my ($command, $pre_post) = @_;
	PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] Execution of '.$pre_post.'-backup script failed.')
		if (execute($command));
}

####
# check the presence of the binaries @_ on the local system using 'which'
# usage:  check_binary(bin1 [, bin2 ...]);
##
sub check_binary {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    my $which = "$ENV{'PATH'} which";
    foreach my $app (@_) {
	verbose("=> check availability of the command '$app' on the local system...");
	verbose("\n") if (($DEBUG) || ($SIMULATION_MODE));
       	my $exit_status = execute("which $app 1>/dev/null");
	PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . "] unable to find the application $app on your system (using PATH=$ENV{'PATH'})") if ($exit_status);
	verbose("\tOK\n");
    }
}

####
# Append the text prefixed by [dd/mm/yy-hh:mm:ss] to the log file defined as $SETTINGS{'log_file'}. 
# if $SETTINGS{'log_file'} is not defined, then the log message is printed on STDERR
# usage : 
##
sub append_to_log {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing text argument') unless @_;
    my $output;
    if (defined($SETTINGS{'log_file'})) {
	open($output, ">>", $SETTINGS{'log_file'});
    } else {
	$output = *STDERR;
	print $output '[' . color('yellow') . "LOG" . color('reset') . ']';
    }
    print $output strftime('%Y-%m-%d %Hh%M:%Ss', localtime)." @_\n";
    close($output) if defined($SETTINGS{'log_file'});
}

######
# get current IPs adresses using ifconfig. 
# return an hash table associating an interface name with an IP and a state (up or down)
##
sub getIPs {
    my $interface;
    my %IPs;
    foreach ( qx{ (LC_ALL=C /sbin/ifconfig -a 2>&1) } ) {
        $interface = $1 if /^(\S+?):?\s/;
        next unless defined $interface;
        $IPs{$interface}->{STATE}=uc($1) if /\b(up|down)\b/i;
        $IPs{$interface}->{IP}=$1 if /inet\D+(\d+\.\d+\.\d+\.\d+)/i;
    }
    return %IPs;
}

######
# get current IP adresses associated with an interface. 
# If the interface parameter is not procided, the checked interfaces ar e (eth0, eth1) on Linux system 
# and (en0, en1) on BSD-like. 
# usage: getIPFromInterface(interface) 
##
sub getIPFromInterface {
    my %IPs = getIPs();
    debug("Analysing IPs on the local system. Found:\n");
    debug(Dumper \%IPs);
    my @interfaces;
    if (@_) {
	@interfaces = ($_[0]);
    } else {
	@interfaces = ('eth0', 'eth1') if ($OS[0] eq "Linux");
	@interfaces = ('en0',  'en1')  if ($OS[0] =~ "FreeBSD|OpenBSD|Darwin");
    }
    foreach my $i (@interfaces) {
	return $IPs{$i}->{IP} if ($IPs{$i} && $IPs{$i}->{IP});
    }
    PRINT_ERROR_THEN_EXIT("IP not found for interface(s) @interfaces");
    return;
}

####
# check if the IP associated with an interface match another subnet. 
# If no interface argument is provided, then  
# usage: check_subnet(subnet [, interface])
##
sub check_subnet {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    my $subnet = $_[0];
    my $IP = "";
    $IP = ($_[1] ? getIPFromInterface($_[1]) : getIPFromInterface());
    verbose("=> check subnet $subnet (current IP address found : $IP)...");
    unless ($IP =~ "$subnet") {
	verbose("\n");
	warning "The IP adress $IP does not belong to the subnet $subnet => no backup to be done\n";
	exit 2;
    }
    verbose("\t OK\n")
}

####
# check the existence of a given section in the configuration file
# usage: ensure_section_exists('section_name')
##
sub ensure_section_exists {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    foreach my $sec (@_) {
	PRINT_ERROR_THEN_EXIT("The section $sec cannot be found in the configuration file and is required (man backup.conf for more info)") unless exists($CONFIGS{$sec});
    }
}

####
# ensure the fields in @_ are undefined in %SETTINGS
# usage: ensure_undefined_settings('field')
##
sub ensure_undefined_settings {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    foreach my $field (@_) {
	PRINT_ERROR_THEN_EXIT("The directive $field is defined in the settings yet it should be unitialized at this step") if defined($SETTINGS{$field});
    }
}

####
# check defined field in %SETTINGS
# usage: ensure_defined_settings('field')
##
sub ensure_defined_settings {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    foreach my $field (@_) {
	PRINT_ERROR_THEN_EXIT("The directive $field is mandatory yet undefined in your configuration") unless defined($SETTINGS{$field});
    }
}

#####
# check the availability of the command rsync on the local machine and on the remote backup server
###
sub check_rsync_availability {
    # first check rsync on the local system
    check_binary('rsync');
    if ($BACKUP_CMD_INFO{'proto'} eq 'ssh') {
	verbose("=> check availability of the command 'rsync' on $BACKUP_CMD_INFO{'target'}...");	
	verbose("\n") if ($DEBUG || $SIMULATION_MODE);
	my $exit_status = ssh_remote_execute($BACKUP_CMD_INFO{'target'}, $BACKUP_CMD_INFO{'port'}, "which rsync");
	PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . "] unable to find the application 'rsync' on $BACKUP_CMD_INFO{'target'}") if ($exit_status);
	verbose("\tOK\n");
    }
}

####
# Update the global variable from a hash table passed as arguments (typically a subsection from %CONFIGS)
# usage: update_settings_from(hash_table)
##
sub update_settings_from {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    my %subsection = %{ dclone($_[0])};   # deep copy 
    while (my ($key, $val) = each(%subsection)) {
	if ($key eq 'ssh_auth_sock') { 
	    $ENV{SSH_AUTH_SOCK} = interpret_cmd($subsection{'ssh_auth_sock'});
	    debug "Setting the environment variable SSH_AUTH_SOCK to $ENV{SSH_AUTH_SOCK}\n";
	    next;
	} 
	if (($key eq 'Directory') && defined($SETTINGS{$key})) {
	    # Here we need to append the directories definitions
	    while( my ($dir, $dir_setting) = each(%{$subsection{$key}})) {
		$SETTINGS{$key}->{$dir} = $dir_setting;
	    }
	    next;
	}
	if (exists($SETTINGS{$key})) {
	    $SETTINGS{$key} = $val;
	} else {
	    PRINT_ERROR_THEN_EXIT("The directive $key is not recognized\n");
	}
    }
}

####
# reset the settings
##
sub reset_settings {
    %SETTINGS        = %DEFAULT_SETTINGS;
    %BACKUP_CMD_INFO = %DEFAULT_BACKUP_CMD_INFO; 
}

####
# restore the settings from the global section
##
sub restore_global_settings {
    reset_settings();
    update_settings_from($CONFIGS{'global'});
}

####
# configure the synchronization once the settings are finalized
##
sub configure_sync_cmd {
    if ($SETTINGS{'use_duplicity'} =~ /1|y|yes/i) {
	PRINT_ERROR_THEN_EXIT("The use of duplicity is not yet supported");
    }
    # setup  source basedir (always on the local machine)
    setup_backup_cmd_info_src();
    # setup destination basedir
    info("analysing target url $SETTINGS{'target_url'}\n", "   -");    
    parse_target_url();
    # setup directories to backup/restore
    info("setup local directories to " . ($RETRIEVE_MODE ? "restore" : "backup") . "\n", "   -");
    setup_directories_to_sync();
    verbose("\tfound:  @{$BACKUP_CMD_INFO{'dirs'}}\n");
    PRINT_ERROR_THEN_EXIT("No directory to " . ($RETRIEVE_MODE ? "restore" : "backup")) unless (@{$BACKUP_CMD_INFO{'dirs'}});
    # Check command availability both locally and on the target
    check_rsync_availability unless ($QUIET);
    # add options
    treat_cmd_options();
    print_current_cmd_info();
}

####
# run the synchronization command
##
sub run_sync_cmd {
    # First check subnet
    check_subnet($SETTINGS{'restrict_on_subnet'}) if ($SETTINGS{'restrict_on_subnet'});
    
    # So far no support for ssh + backup history
    PRINT_ERROR_THEN_EXIT("In this version historical backups are not compatible with ssh target.")
      if ($BACKUP_CMD_INFO{'proto'} eq 'ssh' && $HISTORICAL);
    
    # So far no support for retrieve + backup history
    PRINT_ERROR_THEN_EXIT("In this version historical backups are not compatible with retrieve operation.")
      if ($RETRIEVE_MODE && $HISTORICAL);
    
    # Set timestamp if historical backup
    my $datestamp = $HISTORICAL ? strftime('%Y-%m-%d_%Hh%Mm%Ss', localtime) : "";
    
    if ($RETRIEVE_MODE) {
	warning('You are about to '. color('red') . color('bold') . 'retrieve ' .color('reset') . color('reset') . 
	        "the directories '@{$BACKUP_CMD_INFO{'dirs'}}' from $BACKUP_CMD_INFO{'target'}\n");
	warning("This will " . color('red') . color('bold') . 'overwrite files on your local system.' .color('reset').color('reset') . "\n");
	really_continue() unless $QUIET;
    } else {
	warning("Your are about to backup the directories '@{$BACKUP_CMD_INFO{'dirs'}}' on $BACKUP_CMD_INFO{'target'}.\n") unless $QUIET;
	really_continue() unless $QUIET;
	# create basedir on target
	create_dir_on_target("$BACKUP_CMD_INFO{'dst'}/$datestamp$BACKUP_CMD_INFO{'src'}") unless $RETRIEVE_MODE;
    }
    notification("Starting backup", "iBackup is starting backup of ".$BACKUP_CMD_INFO{'src'}." on ".$BACKUP_CMD_INFO{'target'}) if $NOTIFICATION;
    
    my $failure = 0;
    foreach my $dir (@{$BACKUP_CMD_INFO{'dirs'}}) {
	info("proceeding directory " . color('bold') . "$dir" . color('reset') . "\n", "   ---->");
	my $src_basedir = "$BACKUP_CMD_INFO{'src'}";
	my $dst_basedir = "$BACKUP_CMD_INFO{'dst'}/$datestamp$BACKUP_CMD_INFO{'src'}";
	my $dst_linkdir = readlink($BACKUP_CMD_INFO{'dst'}.'/latest').$BACKUP_CMD_INFO{'src'} if ($HISTORICAL && -l $BACKUP_CMD_INFO{'dst'}.'/latest');
	my ($src_dir, $dst_dir) = ($dir, $dir);
	# Manage special treatment of the directory
	if (exists($SETTINGS{'Directory'}->{$dir})) {
	    # First interpret included commands
	    foreach my $directive (keys %{$SETTINGS{'Directory'}->{$dir}}) {
		$SETTINGS{'Directory'}->{$dir}->{$directive} = interpret_cmd("$SETTINGS{'Directory'}->{$dir}->{$directive}");
	    }
	    verbose("   using special settings : \n");
	    verbose("   " . Dumper $SETTINGS{'Directory'}->{$dir});
	    my $sep  = ($BACKUP_CMD_INFO{'proto'} eq 'ssh') ? ':' : '/';
	    $dst_basedir = "$BACKUP_CMD_INFO{'target'}$sep$SETTINGS{'Directory'}->{$dir}->{'dst_rootdir'}" if $SETTINGS{'Directory'}->{$dir}->{'dst_rootdir'};
	    #$dst_linkdir = "$BACKUP_CMD_INFO{'target'}$sep$SETTINGS{'Directory'}->{$dir}->{'dst_rootdir'}" if $SETTINGS{'Directory'}->{$dir}->{'dst_rootdir'};
	    if ((! $RETRIEVE_MODE) && 
		($SETTINGS{'Directory'}->{$dir}->{'src_in_subfolder'})) 
	      {
		  verbose("=> setup src differentiation for the directory $dir on the target $BACKUP_CMD_INFO{'target'}\n");
		  $dst_basedir .= "/$dir";
		  $dst_linkdir .= "/$dir" if ($HISTORICAL && -l $BACKUP_CMD_INFO{'dst'}.'/latest'); 
		  # create directory on target 
		  create_dir_on_target("$dst_basedir");
		  $dst_dir = $SETTINGS{'Directory'}->{$dir}->{'src_in_subfolder'};
	      }
	}
	unless  (($RETRIEVE_MODE) || (-d "$src_basedir/$src_dir")) {
	    # check existence of src dir
	    warning("The source directory '$src_basedir/$src_dir' does not exist => skipping $dir\n");
	    next;
	}
	# Inverse src_basedir and dst_basedir if $RETRIEVE_MODE
	($src_basedir, $dst_basedir) = ($dst_basedir, $src_basedir) if ($RETRIEVE_MODE);
	
	# Add historical backup options if required
	my $hist_opt = ($HISTORICAL && -l $BACKUP_CMD_INFO{'dst'}.'/latest')   ?
	  " --link-dest ".$dst_linkdir."/".$dst_dir : "";
	
	my $cmd = "$BACKUP_CMD_INFO{'basecmd'} $BACKUP_CMD_INFO{'opt'}$hist_opt $src_basedir/$src_dir/ $dst_basedir/$dst_dir";
	append_to_log("$cmd");
	$failure += execute($cmd);
    }
    
    execute('unlink '.$BACKUP_CMD_INFO{'dst'}.'/latest') if ($HISTORICAL && -l $BACKUP_CMD_INFO{'dst'}.'/latest');
    execute('ln -s '.$BACKUP_CMD_INFO{'dst'}.'/'.$datestamp.' '.$BACKUP_CMD_INFO{'dst'}.'/latest') if ($HISTORICAL);
    
    notification("Backup failed!", "Backup to $BACKUP_CMD_INFO{'target'} failed!", 1) if ($failure && $NOTIFICATION);
    notification("Backup succeeded", "Backup to $BACKUP_CMD_INFO{'target'} succeeded.", 0) if (!$failure && $NOTIFICATION);
}

###
# Clean the local system after the synchronization i.e. unmount volumes etc. 
##
sub clean_after_sync {
    debug("List of mounted volumes : \n" . Dumper \%MOUNTED_VOLUMES);
    foreach my $proto (keys %MOUNTED_VOLUMES) {
	if (defined ($MOUNTED_VOLUMES{$proto})) {
	    my $umount_cmd = "";
	    $umount_cmd = "umount "         if ($proto =~ "drive|afp");
	    $umount_cmd = "hdiutil detach -quiet " if ($proto eq 'sparsebundle');
	    PRINT_ERROR_THEN_EXIT("No unmount command set!\n") unless ($umount_cmd);
	    
	    foreach my $vol (@{$MOUNTED_VOLUMES{$proto}}) {
		info("Unmounting the volume $vol (mounted via $proto)\n");
		execute("$umount_cmd $vol");
	    }
	}
    }
}


####
# specialize the command options
##
sub treat_cmd_options {
    # Treat patternfile_exclude
    if (defined($SETTINGS{'patternfile_exclude'})) {
	if (-f $SETTINGS{'patternfile_exclude'}) {
	    $BACKUP_CMD_INFO{'opt'} .= " --exclude-from=$SETTINGS{'patternfile_exclude'}";
	} else {
	    warning("The pattern file for exclusion $SETTINGS{'patternfile_exclude'} does not exists and will be ignored\n");
	}
    }
    # Add classical options
    $BACKUP_CMD_INFO{'opt'} .= " -avz";
    #$BACKUP_CMD_INFO{'opt'} .= " -E" if $MAC_FORK;
	$BACKUP_CMD_INFO{'opt'} .= " -NHAX --protect-args --fileflags --force-change" if ($MAC_FORK && !$BACKUP_CMD_INFO{'proto'} eq 'ssh');
#    $BACKUP_CMD_INFO{'opt'} .= " --progress" if $VERBOSE;
    $BACKUP_CMD_INFO{'opt'} .= " --quiet"    if $QUIET;
    $BACKUP_CMD_INFO{'opt'} .= " $SYNC_MODE";  
}


####
# initialize $BACKUP_CMD_INFO{'src'} (i.e the basedir of the local folders to backup) to
# $SETTINGS{'src_rootdir'}, ensuring this directory exists
###
sub setup_backup_cmd_info_src {
    my $src_rootdir = interpret_cmd($SETTINGS{'src_rootdir'});
    PRINT_ERROR_THEN_EXIT("The directory $src_rootdir cannot be found on this computer") unless ( -d $src_rootdir);
    $BACKUP_CMD_INFO{'src'} = $src_rootdir;
}

####
# interpret commands delimited by ` ` in a string. 
# Return the string where `cmd` is replaced by the result of the command 
# usage: interpret_cmd("string")
##
sub interpret_cmd {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    my $string = my $ref = $_[0]; 
    my @commands = $string =~ /`([^`]+)`/g; # retrieve commands to interpret
    foreach my $cmd (@commands) {
	my $cmd_exec = `$cmd` || PRINT_ERROR_THEN_EXIT("Execute of $cmd failed or return and empty string: $!\n");
	chomp($cmd_exec);
	$cmd =~ s/\$/\\\$/g;  # Serialize command
	$cmd =~ s/\|/\\\|/g;  # idem
	$ref =~ s/`$cmd`/$cmd_exec/;
    }
    return $ref;
}

####
# Parse the target url 
##
sub parse_target_url {
    PRINT_ERROR_THEN_EXIT("Undefined target url") if ! defined($SETTINGS{'target_url'});
    $SETTINGS{'target_url'} = interpret_cmd("$SETTINGS{'target_url'}");
    $SETTINGS{'target_url'} =~ /^\b(\w+):\/\/(([\.\w\/]+)((\@([\w\.]+))(:(\d+))?)?)/;
    my ($proto, $target, $user, $server, $port) = ($1, $2, $3, $6, $8);
    #my ($proto, $target) = split('://', $SETTINGS{'target_url'});
    debug("Protocol: $proto\n")  if ($proto);
    debug("target  : $target\n") if ($target);
    debug("user    : $user\n")   if ($user);
    debug("server  : $server\n") if ($server);
    debug("port    : $port\n")   if ($port);
    PRINT_ERROR_THEN_EXIT("Malformed url $SETTINGS{'target_url'}") unless ($proto && $target);
    $BACKUP_CMD_INFO{'proto'} = $proto;
    $BACKUP_CMD_INFO{'target'} = $target;
    
    # Handle each prototype
    switch ($proto) {
	# Local drive
	case 'drive' 
	  { 
	   verbose("\tsetup target on the external drive $target\n"); 
	   setup_target_drive($target);
	  }
	# Local directory 
	case 'file'  
	  { 
	   verbose("\tsetup target on the local directory $target\n"); 
	   setup_target_drive($target);
	  }
	# Remote server reacheable by ssh 
	case 'ssh'   
	  { 
	   PRINT_ERROR_THEN_EXIT("Malformed ssh target") unless ($user && $server);
	   $port = 22 unless ($port);
	   verbose("\tsetup target on the remote server $server.\n");
	   verbose("\tConnection to be established for the remote user $user by ssh on port $port\n"); 
	   setup_target_ssh($user, $server, $port);
	  }
	# sparsebundle
	case 'sparsebundle'
	  {
	   PRINT_ERROR_THEN_EXIT("Sparsebundle images are only supported under Mac OS X") unless ($OS[0] =~ "Darwin");
	   verbose("\tsetup target on the sparsebundle image $target\n");
	   setup_target_sparsebundle($target);
	  }
	# ERROR: NOT supported => raise error
	else { PRINT_ERROR_THEN_EXIT("The protocol $proto is not supported"); }
    }
}

###
# setup the command for a backup on an external drive or a local directory
# usage: setup_target_drive(path)
##
sub setup_target_drive {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
    $BACKUP_CMD_INFO{'dst'} = interpret_cmd($_[0]);
    # Ensure the target drive starts with a '/'
    if ($BACKUP_CMD_INFO{'dst'} !~ /^\//) {
	warning("The target drive path ($BACKUP_CMD_INFO{'dst'}) does not starts with a '/' => '/' character added\n");
	$BACKUP_CMD_INFO{'dst'} = "/$BACKUP_CMD_INFO{'dst'}";
    }
    PRINT_ERROR_THEN_EXIT("The target $BACKUP_CMD_INFO{'dst'} cannot be found") unless ( -d "$BACKUP_CMD_INFO{'dst'}");
    push(@{$MOUNTED_VOLUMES{ $BACKUP_CMD_INFO{'proto'} }}, $BACKUP_CMD_INFO{'dst'});
}

###
# setup the command for a backup on a remote server reacheable by ssh 
# usage: setup_target_drive(user, server, ssh_port)
##
sub setup_target_ssh {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (scalar(@_) == 3);
    my ($user, $server, $port) = @_;
    $BACKUP_CMD_INFO{'port'}   = $port;
    $BACKUP_CMD_INFO{'target'} = "$user" . '@' . "$server";
    if ($BACKUP_CMD_INFO{'basecmd'} eq 'rsync') {
	$BACKUP_CMD_INFO{'opt'} .= "--rsh=" . (($port == 22) ? "ssh" : "'ssh -p $port'");
	$BACKUP_CMD_INFO{'dst'} = "$user" . '@' . "$server:" . interpret_cmd($SETTINGS{'dst_rootdir'});
    } else {
	PRINT_ERROR_THEN_EXIT("rsync is the only supported command currently");
    }
 #   ssh_remote_execute($BACKUP_CMD_INFO{'target'}, $port, "hostname") || 
  #    die "unable to connect by ssh to $BACKUP_CMD_INFO{'target'} (port $port): $!\n";
}

###
# setup the command for a backup on a sparsebundle image
# usage: setup_target_sparsebundle(path)
##
sub setup_target_sparsebundle {
	PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing argument') unless (@_);
	my $sparsebundle = $_[0];

	# test if the sparsebundle is really there
	PRINT_ERROR_THEN_EXIT("The sparsebundle $sparsebundle cannot be found") unless (-e $sparsebundle);

	# Now mount it
	my $attach_cmd = "hdiutil attach $sparsebundle -plist";
	if ($SIMULATION_MODE) {
	    execute($attach_cmd);
	    $BACKUP_CMD_INFO{'dst'} = "/Volumes/Backup_Drive";
	} else {
	    debug("Running '$attach_cmd'\n");
	    my $plist_str = `$attach_cmd`;
	      
	    # Run the attach command and retrieve the plist infos
	    my $plist = Mac::PropertyList::parse_plist( "$plist_str" );
	    # Extract from it the mount point 
	    my $mount_point = ""; 
	    foreach my $dict ($plist->{'system-entities'}->value()) {
		next unless $dict->exists('mount-point');
		$mount_point = $dict->{'mount-point'}->value();		
	    }
	    PRINT_ERROR_THEN_EXIT("The mount point associated to the sparsebundle $sparsebundle cannot be found")
		unless ($mount_point);
	    debug("Mount point associated to $sparsebundle : ". color('bold') . $mount_point . color('reset') . "\n");

	    PRINT_ERROR_THEN_EXIT("The sparsebundle $sparsebundle cannot be mounted (in $mount_point)\n") unless (-d $mount_point);
	    $BACKUP_CMD_INFO{'dst'} = "$mount_point";
	    push(@{$MOUNTED_VOLUMES{ $BACKUP_CMD_INFO{'proto'} }}, $BACKUP_CMD_INFO{'dst'});
	}	
}

####
# construct difference between two arrays @A and @B i.e 
# elements elements in @A that are not in @B
# usage: array_diff(\@A, \@B);
##
sub array_diff {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] wrong argument number') unless (scalar(@_) == 2);
    my $a_ref = $_[0];
    my $b_ref = $_[1];
    my %seen = ();      # lookup table
    my @res = ();       # initialize the final receip
    @seen{@{$b_ref}} = (); # build lookup table
    foreach my $item (@{$a_ref}) {
	push(@res, $item) unless exists $seen{$item};
    }
    return @res;
}

####
# create the appropriate dirs field from $BACKUP_CMD_INFO using 
# $SETTINGS{'include_dir'} and $SETTINGS{'exclude_dir'}
# The '*' wildcard is used relatively to $SETTINGS{'src_rootdir'}
###
sub setup_directories_to_sync {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . "] \$BACKUP_CMD_INFO{'dirs'} already defined to $BACKUP_CMD_INFO{'dirs'}") if defined($BACKUP_CMD_INFO{'dirs'});
    # ensure $SETTINGS{'include_dir'} is defined
    ensure_defined_settings('include_dir'); 
    
    my @include_dir = expand_wildcard_dirs($SETTINGS{'include_dir'}, $SETTINGS{'src_rootdir'});
    if (defined($SETTINGS{'exclude_dir'})) {
	my @exclude_dir = expand_wildcard_dirs($SETTINGS{'exclude_dir'}, 
					       $SETTINGS{'src_rootdir'});
	if (defined($SETTINGS{'exclude_dir_exception'})) {
	    my @exclude_dir_exception = expand_wildcard_dirs($SETTINGS{'exclude_dir_exception'},
							     $SETTINGS{'src_rootdir'});
	    @exclude_dir = array_diff(\@exclude_dir, \@exclude_dir_exception);
	}
	@include_dir = array_diff(\@include_dir, \@exclude_dir);
    }
    # populate final receipt for the directories to backup
    $BACKUP_CMD_INFO{'dirs'} = dclone \@include_dir;
}

####
# create the physical directory on the target (depends on the considered protocol)
##
sub create_dir_on_target {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] missing directory argument') unless (@_);
    foreach my $dir (@_) {
	info("creating directory $dir\n", "    ");
	my $exit_status;
	switch ($BACKUP_CMD_INFO{'proto'}) {
	    case /drive|file|sparsebundle/ { execute("mkdir -p $dir"); 
				$exit_status = $?;
			      }
	    case 'ssh'        { my $target = "$BACKUP_CMD_INFO{'target'}:";
				$target =~ s/\@/\\\@/g;
				$dir =~ s/^$target//;
				# now run the command on the server
				ssh_remote_execute($BACKUP_CMD_INFO{'target'}, 
						   $BACKUP_CMD_INFO{'port'},
						   "mkdir -p $dir");
			       $exit_status = $?;
			      }
	      else { PRINT_ERROR_THEN_EXIT("Protocol not supported"); }
	}
	PRINT_ERROR_THEN_EXIT("Unable to create the directory $dir") if ($exit_status);
    }
}


####
# expand the wildcards present in a string containing a space separated list of directories
# usage: expand_wildcard_dirs("list of dirs", "root_dir");
##
sub expand_wildcard_dirs {
    PRINT_ERROR_THEN_EXIT( '[' . (caller(0))[3] . '] wrong argument number') unless (scalar(@_) == 2);
    my @dirs = split(/\s+/, $_[0]);
    return @dirs if ($_[0] !~ /\*/);

    my $rootdir = $_[1];
    my @res = ();
#    for my $index (0 .. scalar(@dirs)-1) {
    for my $index (0 .. @dirs-1) {
	my $dir = $dirs[$index];
	if ($dir !~  /\*|\^|\$/) {
	    push(@res, $dir);
	    next;
	} else {
	    my $pattern = $dir;
	    opendir(DIR, $rootdir) || die "Couldn't open $rootdir : $!\n";
	    $pattern =~ s/\./\\\./g;   # proceed with the '.' characters
	    $pattern =~ s/\*/\.\*/g;   # proceed with the '*' characters
	    my @expanded_dir = map { $_->[0] }                # extract subdir name
		               grep { -d $_->[1] }            # check absolute path is a dir
			       map  { [ $_, "$rootdir/$_" ] } # create name, absolute path
			       grep { !/^\.\.$/}              # filter out .. entry
			       grep { !/^\.$/}                # filter out . entry
			       grep { /$pattern/ }            # apply pattern filter
				 readdir(DIR);
	    closedir(DIR);
	    #debug("The pattern " . color('bold') . "$dir" . color("reset") . " relative to $rootdir has been expanded to : "  . color('bold') . "@expanded_dir" . color("reset") . "\n");
	    push(@res, @expanded_dir);
	}
    }
    return @res;
}

####
# Print script version
##
sub VERSION_MESSAGE {
    print <<EOF;
This is $command v$VERSION.
Copyright (c) 2009 Sebastien Varrette  (http://www-id.imag.fr/~svarrett/)
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
}

######################## POD documentation ########################
=pod

=head1 NAME

I<backup>, a highly flexible script utility to backup directories from your local 
system on various targets (external drive, sparsebundle, remote server with SSH access etc.)

I<backup> relies for that on B<rsync> (see L<http://samba.anu.edu.au/rsync/>) and 
(in a future release) B<duplicity> (see L<http://duplicity.nongnu.org/>) together with a 
configuration file.

=head1 SYNOPSIS

      ./backup [options] 

=head1 DESCRIPTION

I<backup> rely on a configuration file to describe the characteristics of a backup to be 
performed (files to include/exclude, target url etc. -- see L<CONFIGURATION FILE FORMAT> 
for more details). Here is a illustrative examples: 

    # Configuration file example
    #
    #### Mandatory global settings #### 
    <global>
         src_rootdir = $HOME     # Root directory on the (local) source
         include_dir = *         # backup all sub-directories (relative to src_rootdir)
    </global>

    #### Mandatory default backup definition ####
    <default>
         target_url = drive:///Volumes/Backup  # backup on an external drive 'Backup'
    </default>

    # Definition of the backup on the server 'toto'
    <toto>
         target_url  = ssh://mylogin@toto.example.org  # backup through ssh
         dst_rootdir = /backup/`whoami`@`hostname`     # Root directory on target server
         restrict_on_subnet = 192.168  # backup only when your machine belongs to this subnet
	# Special treatment of the "Music" subdirectory
	<Directory Music>
		 dst_rootdir = /multimedia  # change the rootdir on target for this folder
	</Directory>
    </toto>

So appart from the 'global' section, each backup is defined in a named block that helps 
to complete and/or overwrite the global settings.
To run the backup configured by default, just run:
 
    ./backup -f /path/to/config_file

To run the backup configured by the 'toto' section, just run:

    ./backup -f /path/to/config_file -s=toto

If a configuration file is not passed command-line through the C<-f> option, I<backup>
use by default $HOME/.backup.conf and then /etc/backup.conf.

To restore data from the backup 'toto', run : 

    ./backup -f /path/to/config_file -s=toto -r

=head1 OPTIONS

The following options are available:

=over 12

=item B<--debug>

Debug mode. Display debugging information probably only relevant to me ;)

=item B<--dry-run   -n>

Simulate the operations to show what would have been done and/or transferred but do 
not perform any backend actions.

=item B<--exact-sync  -e>

Exact synchronization mode. 
Causes I<backup> to delete files on the target if absent in the source directory. 
This ensure an exact replica but you may loose files so use this option with caution.

=item B<--history>

(Experimental) Keeps an history of backups. Each backup creates a timestamped
directory in the specified target where files are backuped. To limit disk usage,
unchanged files are hard linked with existing version on target. Up-to-date
snapshot is always available under the "latest" directory.
(Not yet supported)   Backup with history over SSH
(Not yet implemented) Behavior on target disk full
(Not yet implemented) History consolidation
(Not yet implemented) Retrieve mode from latest snapshot

=item B<--mac-fork  -m>

Use Mac OS resource fork for backup.
Causes I<backup> to use the Mac OS resource forks when calling the rsync function.
This will preserve Mac OS extended attributes 

=item B<--help  -h>

Display a help screen and quit.

=item B<--push -p>

Push mode: push data on the backup target. This is the default behaviour of  I<backup>.

=item B<--quiet>

Quiet mode. Minimize the number of printed messages and don't ask questions. 
Very useful for invoking this script in a crontab yet use with caution has all 
operations will be performed without your interaction.

=item B<--notification>

Activates user notification of backup status.
This feature requires growlnotify (under Mac OS X) or notify-send (under Linux)
to be installed and in your applications path.

=item B<--restore  --retrieve  -r>

Retrieve mode: restore data from the backup. Use with caution as this will probably 
overwrite files on your local machine!

=item B<--pre-script>

Execute the script whose complete path is specified with this argument BEFORE the backup operation.
If the execution of this script fails, the backup will not continue.

=item B<--post-script>

Execute the script whose complete path is specified with this argument AFTER the backup operation.

=item B<--section=SECTION[, SECTION2 ...]>

=item B<-s=SECTION[, SECTION2 ...]>

Specify the successive sections to use for the backup configuration. 
If this option is not set, I<backup> will use the section B<default>.
Currently, the implementation make the script exits as soon as an error happens 
(wrong subnet, target drive not available etc.) yet future release will just go on the 
next backup section on error which will be helpfull for crontab configuration. 


=item B<--verbose  -v>

Verbose mode. Display more information

=item B<--version>

Display the version number then quit. 

=back

=head1 CONFIGURATION FILE FORMAT

The configuration file for I<backup> is divided into sections defined as blocks.
A block looks much like a block in the wellknown apache config format. 
It starts with C<< <blockname> >> and ends with C<< </blockname> >>

Two sections are mandatory: 'global' (which define global settings for the backup) and 
'default' (which refer to the default backup configuration). 
Each additionnal section is considered as a separate backup configuration and can be 
refered using the command-line option C<-s> (see L<"DESCRIPTION">).

When defining directory lists, you may use the following patterns symbols: 
the wildcard C<*>, the symbol C<^> to specify the begining
of a name and the symbol C<$> to refer to its end.
For instance, you can use the following patterns: 

=over 4

=item * C<*> : all sub-directories (including the hidden one that starts with '.')

=item * C<^AR*> : all subdirectories whose name starts by AR

=item * C<*ES$> : all subdirectories whose name ends by ES

=item * C<^.*>  : all hidden directories (the one that starts by '.')

=back

The following directives are recognized: 

=over 8

=item B<< <Directory DIR> ... </Directory> >>

This directive makes it possible to specialize the behaviour of I<backup> for the 
directory DIR. You may overwrite the following options  

=over 4

=item * B<dst_rootdir = ROOTDIR> 

see C<dst_rootdir>

=item * B<src_in_subfolder = SUBDIR> 

this sub section is used to separate on the target 
the files and subfolders in DIR into a subdirectory named 'SUBDIR'. 
For instance, let assume one want to synchronize the B<$HOME/.ssh> folder from 
multiples computers B<comp1>, B<comp2> etc. on the server B<target_server>, each computer 
running the I<backup> script. 
Unless any special behaviour, the files B<$HOME/.ssh/id_dsa*> will be overwritted on 
B<target_server> every time the script is invoked on the computers. 
On the other hand, assuming we have set the B<src_in_subfolder> directive as follow: 

      <Directory .ssh>
          src_in_subfolder = `hostname`
      </Directory>

Then the B<$dst_rootdir/$HOME/.ssh> folder on the target server B<target_server> will 
contain subfolders B<comp1>, B<comp2> etc., each containing the files and subdirs of
B<$HOME/.ssh/> from the source computer. 
In other work, you will be in the following configuration: 

        On'comp1':             On 'comp2':                 on 'target_server':
    $HOME/.ssh/id_dsa       $HOME/.ssh/id_dsa        $dst_rootdir/$HOME/.ssh/comp1/id_dsa  
    $HOME/.ssh/id_dsa.pub   $HOME/.ssh/id_dsa.pub    $dst_rootdir/$HOME/.ssh/comp1/id_dsa.pub
                                                     $dst_rootdir/$HOME/.ssh/comp2/id_dsa  
                                                     $dst_rootdir/$HOME/.ssh/comp2/id_dsa.pub 

This directive is ignored in retrieve mode (see option C<-r>)

=back

=item B<dst_rootdir = ROOTDIR>

Root directory on the backup target (C</> by default)

=item B<exclude_dir = PATTERN1 [PATTERN2] [PATTERN3]...>

Space separated list of directories to exclude from synchronization (relative to B<$src_rootdir>).
You may use the pattern symbols C<*>, C<^> and C<$> for each element of the list. 

=item B<exclude_dir_exception = PATTERN1 [PATTERN2] [PATTERN3]...>

Add exceptions to B<exclude_dir> (nice if wildcards have been used)
You may use the pattern symbols C<*>, C<^> and C<$> for each element of the list. 

=item B<include_dir = PATTERN1 [PATTERN2] [PATTERN3]...>

Space separated list of directories to include from synchronization (relative to B<$src_rootdir>).
You may use the pattern symbols C<*>, C<^> and C<$> for each element of the list. 

=item B<log_file = FILE>

Set FILE as the log file for I<backup>. If not present, logs are printed on STDERR.

=item B<patternfile_exclude = FILE>

The file containing file patterns that should NOT be synchronized. 
For instance, if you don't want to synchronize the temporary files generated by 
I<emacs> or I<vim>, you should put the following entries in FILE: 

        *~
        #*#
        .#*

=item B<restrict_on_subnet = SUBNET> 

Operate the synchronization only when your machine (i.e the network interface) belongs to the subnet 
SUBNET. The successive network interface checked for an IP compared with SUBNET are: 

=over 4

=item * (eth0, eth1) 

on  Linux system (obtained by the I<uname> command)

=item * (en0, en1) 

on FreeBSD, OpenBSD and Darwin systems (which include Mac OS X)

=back

=item B<src_rootdir>

Root directory on the (local) source  (C</> by default)

=item B<ssh_auth_sock = /path/to/ssh-agent.socket>

Set the environment variable C<$SSH_AUTH_SOCK> for this synchronization to the socket 
of the socket file of the ssh-agent instance. 
This is mandatory if you set a passphrase to you SSH key and want the I<backup> script  
to automatically authenticate on a remote server wher you setup an ssh public key 
authentication.

=item B<target_url = URL>

Define the target url of the backup (see L<TARGET URL FORMAT>).

=item B<use_duplicity = yes>

(Not yet supported) use I<duplicity> instead of I<rsync>

=back

=head1 TARGET URL FORMAT

I<backup> tries to maintain a standard URL format for backup targets.  
The generic format for a target URL is:

              protocol://path|user[@host[:port]]

I<backup> don't support the exposure of cleartext passwords on purpose for obvious security 
reasons. 

Current supported protocols include: 

=over 4

=item * C<drive> : an external drive 

Example:  

      drive:///Volumes/MyDrive         (under Mac OS X)
      drive:///mnt/mydrive             (under Linux) 

=item * C<file>  : a local folder

Example: 

      file:///path/to/local/folder

=item * C<sparsebundle> :  a Mac OS X Sparse Bundle [encrypted] image

Example: 

      sparsebundle:///path/to/sparsebundle/image.sparsebundle

With the previous line, the sparse bundle image /path/to/file.sparsebundle 
will be mounted (let's say in /Volumes/ImageName) 

Even if this is not required, it is strongly recommended for encrypted sparsebundle
passwords to be stored in the user keychain. This is mandatory if I<backup>
is to be launched in a crontab for instance.

=item * C<ssh>   : SSH with public key authentication 

Example: 

      ssh://mylogin@server1
      ssh://mylogin@server1.example.org
      ssh://mylogin@server2.example.org:8022

Even if public key authentication is not required, it is strongly recommended and 
mandatory if I<backup> it to be launched in a crontab for instance. 

To setup public key authentication, please refer to L<http://sial.org/howto/openssh/publickey-auth/> 

=back

=head1 BUGS

Please report bugs using informations provided at the page L<http://ibackup.gforge.uni.lu/bugs.html>

=head1 AUTHOR

Original author: Sebastien Varrette -- L<http://varrette.gforge.uni.lu/>

Recently, Guillaume-Jean Herbiet (L<http://herbiet.gforge.uni.lu>) joined me to improve 
the script in many ways (sparsebundle support etc.)

=head1 COPYRIGHT

This  is a free software. There is NO warranty; not even for
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


=cut

# POD documentation to be done: 
#Suggested by Damian Conway in Perl Best Practices.
#Name
#Usage
#Description
#Required arguments
#Options
#Exit status
#Diagnostics
#Configuration
#Dependencies
#Incompatibilities
#Bugs and limitations
#Author
#License and copyright
#Disclaimer of warranty

